https://sql-academy.org/ru/handbook/LENGTH  справочник по функциям MySQL

https://habr.com/ru/articles/247373/  про индексы


Базы данных(БД) - это набор фаилов, хранилище данных, хранящиеся в структурированном виде. 
Системы управленя базами данных(СУБД) - совокупность языковых и программных средств, которая осуществляет доступ к БД и данным, позволяет их создавать, менять и удалять, обеспечивает безопасность и т.д.
Когда мы вводим запрос(например SQL) то он идет в СУБД, она его обрабатывает, отсылает БД, берет оттуда данные и выдает нам.


	1. Key-value базы данных(Redis, Memcached, Etcd):
Они хранят данные как совокупность пар «ключ-значение», в которых ключ это уникальный id. Ключи и значения могут представлять собой что угодно: от простых до сложных составных объектов.
Преимущества: Скорость работы; Простота модели хранения данных; Значения могут быть любыми, включая JSON;
Недостатки: Плохо масштабируются в сложных моделях данных; Неэффективность при работе с группой записей(на входе не имеем инфы кроме ключа); Нет языка запросов(логика зпросов будет в основном коде)

	2. Документоориентированные базы данных(MongoDB, Couchbase, Firebase):
Хранение и запрос данных в виде документов, подобном JSON. Документ это набор атрибутов(ключ и значение). Значения могут быть любыми типами данных(в том числе и ссылки на другие документы)
Позволяет добавлять новую информацию в некоторые записи, не требуя при этом, чтобы все остальные записи в базе данных имели одинаковую структуру
Документы в базе данных адресуются с помощью уникального ключа, обычно это строка, которая генерируется автоматически.
Помимо простого поиска документов по ключу, как в key-value базах данных, они имеют и свой язык запросов. Функционал и синтаксис которого отличается от одной реализации к другой.
> db.users.find({"name": "Daniel"}).count()  (пример запроса в MongoDB)

	3. Реляционные базы данных:
Информация хранится в связанных друг с другом таблицах. Таблицы состоят из строк/записей и столбцов/атрибутов. Каждый столбец имеет определённый тип данных(пр: VARCHAR INTEGER DATETIME)
а. Ключевое поле(первичный ключ)(обязателен, только один но может состоять из нескольких полей) – это поле, значение которого однозначно определяет запись в таблице.
С помощью данного правила СУБД не позволит нам создать новую запись, где id будет неуникальным.
б. Внешний ключ(необязателен, может быть несколько) – это поле в одной таблице, которое ссылается на первичный ключ в другой таблице.
Таблица с внешним ключом называется дочерней, а таблица с первичным ключом называется ссылочной или родительской(одна таблица может быть и той и другой одновременно).
Правило внешнего ключа гарантирует, что при создании записей в дочерней таблице, значение поля, являющегося внешним ключом, есть в родительской таблице.

Для работы с базой данных нам нужно знать язык этой базы данных. Базы данных бывают SQL либо NOSQL(not only).

SQL - Structured Query Language(язык структурированных запросов) - язык запросов к СУБД. Он формулирует запрос к БД и на основе запроса производит различные манипуляции внутри БД
SQL используется во множестве СУБД. Среди таковых можно выделить: MySQL, SQLite, PostgreSQL, Oracle, Microsoft SQL Server и многие другие. 
Многие СУБД вносят свои изменения в язык SQL. Такие языки называют диалектами или расширениями языка(T-SQL – диалект Microsoft SQL Server, PL/SQL – диалект Oracle Database, PL/pgSQL – диалект PostgreSQL).



									SQLite

https://sqlitebrowser.org/dl/  инструмент-браузер для SQLite(мб еще для чегото)

SQLite — это библиотека на языке C, которая реализует небольшой, автономный, полнофункциональный механизм базы данных SQL.

Скачивание и установка: 
https://sqlite.org/index.html  ->  Download  ->  Precompiled Binaries for Windows  ->  https://www.youtube.com/watch?v=ZSOyqH3loss  https://lumpics.ru/how-install-sqlite-on-windows-10/

gem install sqlite3   -  библиотека для Руби


sqlite3 --version   -  проверить версию
sqlite3             -  войти в программу(в оболочку/shell программы) (выход Ctrl+C или прописать .exit)


	1. Создание базы данных в sqlitebrowser:
новая база данных -> выбираем директорию имя фаила и расширение -> фаил базы данной создан
в появившемся окне создаем таблицу добавляя имя таблицы и столбцы с параметрами, 
внизу создание отобразится в синтаксисе кодом нашей таблицы CREATE TABLE "Cars" ("Id" INTEGER PRIMARY KEY AUTOINCREMENT, "Name" VARCHAR, "Price" INTEGER)
	(этот код это запрос к базе данных на создание таблицы с такими параметрами)
	(первая колонка любой таблицы это обычно id, уникальный идентификатор строки)
	(INTEGER - тип данных целые числа, хорошо подходит для id)
	(PRIMARY KEY  - значение всегда должно быть у столбца id)
	(AUTOINCREMENT - значение этого столбца будет автоматически увеличиваться про создании новых строк)
	(VARCHAR - тип данных подразумевает что будет небольшой текст, с заданным числом символов например VARCHAR(50). Но в sqlite VARCHAR==TEXT потому лучше использовать TEXT)
		(по умолчанию VARCHAR/TEXT поддерживают юникод(другие алфавиты) в других базах это отдельные типы NVARCHAR и NTEXT)
теперь наша таблица создана в этой базе данных и в основном окне в списке таблиц появилась наша таблица
во вкладки SQL основного окна можно делать запросы(наполнять или выводить чтото из таблицы)
таблицу можно посмотреть во вкладке "Данные"


Название столбца лучше не делать datetime, тк оно часто зарезервировано. Лучше использовать datestamp/date_stamp/DateStamp


	2. Работа с базой данных через терминал(ТРУЕ способ)
sqlite3 название_базы_данных.расширение                     - войти(в соответсвующей директории) в конкретную базу данных(в ее рабочую текстовую консольную оболочку) например testDB.sqlite
sqlite3 ./DB/leprosorium.db                                 - войти с указанием доп пути
		Команды внутри базы данных:
CREATE TABLE "Some" ("Id" INTEGER PRIMARY KEY AUTOINCREMENT, "Name" VARCHAR, "Price" INTEGER);  - запрс создания новой таблицы в данной базе данных
	(среда позволяет писать запросы в несколько строк соотв в конце запроса(именно запроса не команды) точка с запятой, иначе на другую строку переходит ввод запроса, можно поставить и на новой строке)
.tables                                                     - вывести список таблиц которые существуют вданной базе данных
SELECT * FROM Cars;                                         - пример запроса SELECT, получаем вывод таблицы или ее элементов
.mode column                                                - изменяет визуальный стиль вывода таблицы на такой чтоб колонки были ровными
.headers on                                                 - Включить заголовки(похоже включена автоматически и так в .mode column)
INSERT INTO Cars (Name, Price) VALUES ('Foo', 6743);        - пример запроса INSERT, добавим новую строку в таблицу
.exit                                                       - выйти из базы данных

чтобы в командной строке sqlite3 каждый раз не писать, показывать в столбец и с заголовками, создайте в домашней директории файл .sqliterc с содержимым:
.headers on
.mode column

pragma table_info(articles);  Посмотреть, какие стобцы и их типы и прочее существуют в таблице articles



столбец и поле - алиасы

Имена столбцов и таблиц можно для визуального выделения писать в наклонных кавычках ``

(Базы данных не принято коммитить в репозитории, поэтому в приложениях лучше создавать так. Гит не понимает 2ичный формат БД, то она при изменении будет целиком копироваться каждый коммит.)


									Синтаксис SQL

DESCRIBE TableName                                        #=> посмотреть типы данных столбцов таблицы
SHOW DATABASES;                                           #=> выведет все БД и таблицы(?) а так же служебные(information_schema, mysql, performance_schema, sys)

операторы определения данных (Data Definition Language, DDL):
	CREATE создаёт объект базы данных (саму базу, таблицу, представление, пользователя и так далее)
	ALTER изменяет объект,
	DROP удаляет объект;

	Создание и удаление баз данных:
	(для имени БД можно использовать буквы, цифры, а также символы "_" и "$". Имя может начинаться с цифр, но не может состоять только из них. Максимальная длина имени составляет 64 знака.)
CREATE DATABASE имя_базы_данных;                          #=> создание БД
CREATE DATABASE IF NOT EXIST имя_базы_данных;             #=> создание БД если ее не сущкствует
DROP DATABASE имя_базы_данных;                            #=> удаление БД	
DROP DATABASE IF EXIST имя_базы_данных;                   #=> удаление БД если она сущкствует


	Создание и удаление таблиц:
USE имя_базы_данных;                                      #=> выбрать(ели не выбрана другим образом) базу данных, в которую таблица будет записана.

	PRIMARY KEY    - указывает колонку/колоноки как первичный ключ(первичный ключ всегда уникальный, этим гарантирует уникальность всей строки за счет автоинкремента).
	AUTO_INCREMENT - значение будет автоматически увеличиваться при добавление новых записей. Максимум одна такая колонка. Можно применять только к int и float.
	UNIQUE         - значения в данной колонке для всех записей должны быть отличными друг от друга.
	NOT NULL       - значения в данной колонке должны быть отличными от NULL, тоесть обязательны к заполнению, те если будет не заполнено выдаст ошибку
	DEFAULT        - значение по умолчанию. Данный параметр не применяется к типам BLOB, TEXT, GEOMETRY и JSON.

CREATE TABLE "Some" ("Id" INTEGER PRIMARY KEY AUTOINCREMENT, "Name" TEXT, "Price" INTEGER);                #=> запрс создания новой таблицы в данной базе данных(кавычки не обязательны)
CREATE TABLE Users (id INT, name VARCHAR(255), age INT, PRIMARY KEY (id));                                 #=> PRIMARY KEY можно присваивать и так
CREATE TABLE IF NOT EXISTS "Some" ("Id" INTEGER PRIMARY KEY AUTOINCREMENT, "Name" TEXT, "Price" INTEGER);  #=> создания новой таблицы, если такой еще не существует(избавляет от ошибки если существует)
CREATE TABLE Users (id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, age INT NOT NULL DEFAULT 18)           #=> age - поле числового типа со значением по умолчанию равным 18

	FOREIGN KEY (имя_столбца) REFERENCES Имя_таблицы_с_первичным_ключем (id) - создания таблицы с внешним ключом. REFERENCES - значит ссылка
CREATE TABLE Users (id INT, name TEXT, age INT, company INT, PRIMARY KEY (id), FOREIGN KEY (company) REFERENCES Companies (id)); 
#=> внешний ключ company ссылается на первичный ключ id таблицы Companies
CREATE TABLE Users (id INT, name TEXT, age INT, company INT, PRIMARY KEY (id), FOREIGN KEY (company) REFERENCES Companies (id), FOREIGN KEY (name) REFERENCES People (id));   #=> несколько внеш ключей

ON DELETE RESTRICT - база данных не даст удалить компанию, у которой в таблице Users есть данные(Cannot delete or update a parent row: a foreign key constraint fails)
ON DELETE CASCADE - при удалении компании будут удалены все пользователи, ссылающиеся на эту компанию.
ON DELETE SET NULL - база данных запишет NULL в качестве значения поля company для всех пользователей, работавших в удалённой компании.
ON UPDATE CASCADE - если компания изменит свой идентификатор, то все пользователи (Users) получат новый идентификатор в поле company.

CREATE TABLE Users (id INT, name VARCHAR(255) NOT NULL, age INT NOT NULL DEFAULT 18, company INT, PRIMARY KEY (id), FOREIGN KEY (company) REFERENCES Companies (id) ON DELETE RESTRICT ON UPDATE CASCADE);


	Индексы - При создании индекса и добавления его к полю, вы получаете более быстрый поиск данных по полю(чемто похожи на PRIMARY KEY или FOREIGN KEY, тк они тоже индесы но с уник свойствами)
	(Не нужно прописывать индексы для каждого из полей, так как это негативно скажется на оптимизации БД)
	(Индексы никак визуально не отображаются в таблице ??)

	CREATE INDEX имя_индекса ON имя_таблицы(имя_колонки);  - создание индекса для столбца
CREATE INDEX Someidex ON people(name);              #=> создаем инлекс Someidex для столбца name таблицы people
SELECT name FROM people;                            #=> теперь поиск по этому полю будет быстрее для таблиц с большим колличеством строк

	DROP INDEX имя_индекса ON имя_таблицы(имя_колонки);  - удаление индекса столбца
DROP INDEX Someidex ON people;                      #=> удаляем инлекс Someidex из таблицы people



	ALTER TABLE имя_таблицы ADD имя_поля ТИП_ДАННЫХ; - добавить новое поле(столбец) в таблицу
ALTER TABLE people ADD name VARCHAR(32);                    #=> добавляем в таблицу people новый столбец name

	ALTER TABLE имя_таблицы CHANGE имя_поля новое_имя_поля НОВЫЙ_ТИП_ДАННЫХ ДОП_УСЛОВИЕ; - изменить название, тип данных и доп условие столбца
ALTER TABLE people CHANGE name long_name TEXT NOT NULL      #=> изменяем имя и тип данных столбца name

	ALTER TABLE имя_таблицы DROP COLUMN имя_поля;  - удалить столбец из таблицы
ALTER TABLE people DROP COLUMN name;                        #=> из таблицы people удаляем столбец name


	DROP TABLE [IF EXIST] имя_таблицы;
DROP TABLE "Tablename";                                     #=> удалить таблицу "Tablename" из данной БД


операторы манипуляции данными (Data Manipulation Language, DML):
	SELECT выбирает данные, удовлетворяющие заданным условиям,
	INSERT добавляет новые данные,
	UPDATE изменяет существующие данные,
	DELETE удаляет данные;

операторы определения доступа к данным (Data Control Language, DCL):
	GRANT предоставляет пользователю (группе) разрешения на определённые операции с объектом,
	REVOKE отзывает ранее выданные разрешения,
	DENY задаёт запрет, имеющий приоритет над разрешением;

операторы управления транзакциями (Transaction Control Language, TCL):
	COMMIT применяет транзакцию,
	ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,
	SAVEPOINT делит транзакцию на более мелкие участки.



				Литералы

Литерал — это указанное явным образом фиксированное значение, например, число 12 или строка "kjyglygly". Бывает строковый, числовой, логический, NULL, литерал даты и времени итд

Строка — это последовательность символов, заключённых в одинарные (') или двойные (") кавычки, включает спец символы при помощи "\" например "\n"
Числовые литералы - любые числа: 1, 2.9, 0.01, .2(можно без нуля), +1(для положительного можно писать плюс если надо), -10, -2.2, 1e3(это 1000) 1e-3(это 0.001)
	Арифметические операторы для числовых литералов: % или MOD(Деление по модулю), *(Умножение), +, -, /(Деление 1 / 2 = 0.5), DIV(Целочисленное деление)
		[postgresql] 1/2 == 0.  Нужно переводить во FLOAT например так 1.0*4/5
Литералы даты и времени(тут 30 декабря 1970) - могут быть представлены в формате строки("1970-12-30", "19701230") или числа(19701230).
	можем указывать время отдельно или вместе:
		'2020-01-01' (интерпритируется как дата со временем равным нулю) 1 января 2020, 00:00:00
		hh:mm:ss, hh:mm, hh, ss  -  варианты времени без даты или без отдельных элементов времени
		YYYY-MM-DD hh:mm:ss, YYYYMMDDhhmmss  -  дата и время - '20200101183030' = 1 января 2020, 18:30:30
Логические литералы - TRUE и FALSE, истинность и ошибочность утверждения. При интерпретации запроса, MySQL преобразует их в числа: TRUE и FALSE становятся 1 и 0 соответственно.
NULL - означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или пробел, от того, когда значения вообще нет

[postgresql] - строковые литералы только в одинарных кавычках('') тк двойные воспринимаются как столбец



				Типы данных(по MySQL)

В SQL каждый столбец в таблице должен иметь определённый тип данных, указывающий на то, какая информация может храниться в этом столбце.

		1. Строковый тип данных. Благодаря ему в базе данных хранятся как текстовые, так и различные двоичные данные (например, картинки).

CHAR(X)	   - Содержит текстовые строки. Длина фиксируемая(0 до 255), указывается в скобках при объявлении. Если длина строки меньше указанной, она дополняется правыми пробелами до указанной длины.
VARCHAR(X) - Содержит текстовые строки. Длина строк динамическая. Длина может быть любой в диапазоне от 0 до 65,535

BINARY(X)    - Содержит двоичные строки. Длина фиксируемая(0 до 255), её вы указываете при объявлении.
VARBINARY(X) - Содержит двоичные строки. Длина строк динамическая. Длина может быть любой в диапазоне от 0 до 65,535

BLOB - используется для хранения больших бинарных данных(двоичные строки), таких как картинки. Максимальная длина 65,535 (сортировки и сравнения сохранённых данных у BLOB чувствительны к регистру)
	TINYBLOB - Максимальная длина 255
	MEDIUMBLOB - Максимальная длина 16,777,215
	LONGBLOB - Максимальная длина 4,294,967,295
TEXT - предназначен для хранения больших данных текстового содержания. Максимальная длина 65,535 (сортировки и сравнения сохранённых данных не чувствительны к регистру в полях TEXT)
	TINYTEXT - Максимальная длина 255
	MEDIUMTEXT - Максимальная длина 16,777,215
	LONGTEXT - Максимальная длина 4,294,967,295


		2. Числовые данные разделяются на точные и приближенные, на целые и вещественные. В отдельную категорию можно отнести битовые значения.

	а. Точные целые числа
TINYINT	              - 1 байт(Объем памяти)   от -128 до 127 (от -2**7 до 2**7-1)
TINYINT UNSIGNED      - 1 байт                 от 0 до 255 (от 0 до 2**8-1)
SMALLINT              - 2 байта                от -32768 до 32767 (от -2**15 до 2**15-1)
SMALLINT UNSIGNED     - 2 байта                от 0 до 65535 (от 0 до 2**16-1)
MEDIUMINT             - 3 байта                от -2**23 до 2**23-1
MEDIUMINT UNSIGNED    - 3 байта                от 0 до 2**24-1
INT/INTEGER(синонимы) - 4 байта	               от -2**31 до 2**31-1
INT UNSIGNED          - 4 байта	               от 0 до 2**32-1
BIGINT                - 8 байт	               от -2**63 до 2**63-1
BIGINT UNSIGNED       - 8 байт                 от 0 до 2**64-1

	б. Точные вещественные числа - DECIMAL хранит точное вещественное значение данных. Используется, когда точность является критически важной. Например, при хранении финансовых данных.
	(Синтаксис DECIMAL эквивалентен DECIMAL(M) и DECIMAL(M,0). По умолчанию, параметр M равен 10.)
DEC(M,D) / DECIMAL(M,D) (синонимы) - Зависит от параметров M и D
CREATE TABLE Users ( ... salary DECIMAL(5,2));   - объявляется, что в колонке salary будут хранится числа, имеющие максимум 5 цифр, причём 2 из которых отведены под десятичную часть(от -999.99 до 999.99)
(Целая часть и часть после точки хранятся как 2 отдельных целых числа. У DECIMAL(5,2) целая часть содержит 3 цифры и занимает 2 байта, часть после точки 2 цифры - достаточно 1 байта. Итого 3 байта)

	в. Битовые числа
BIT(M) - От 1 до 64 битов, в зависимости от значения M. Хранит последовательность битов заданной длины. По умолчанию, длина составляет 8 бит. 
	(Если назначаемое значение в колонке с данным типом использует меньше M бит, то происходит дополнение нулями слева. Например b'101' в BIT(6) храниться в итоге будет b'000101')
BOOL/BOOLEAN(синонимы) - 1 бит  те 0 или 1.

	г. Приближенные числа
	(UNSIGNED - предотвращает хранение в отмеченном столбце отрицательных величин, но, в отличие от целочисленных типов, максимальный интервал для величин столбца остаётся прежним.)
FLOAT(M, D)                         - 4 байта     От ±1.17·10**-39    До  ±3.4·10**38
REAL(M, D) / DOUBLE(M, D)(синонимы) - 8 байтов    От ±2.22·10**-308   До  ±1.79·10**308


		3. Дата и время

DATE      - Хранит значения даты в виде ГГГГ-ММ-ДД от 1000-01-01 до 9999-12-31   3 байта.
TIME      - Хранит значения времени в формате ЧЧ:ММ:СС(или ЧЧЧ:ММ:СС для значений с большим количеством часов). от -838:59:59 до 838:59:59   3 байта
DATETIME  - Хранит значение даты и времени в виде ГГГГ-MM-ДД ЧЧ:ММ:СС.  от 1000-01-01 00:00:00 до 9999-12-31 23:59:59    8 байта
	(не зависит от временной зоны - изменении часового пояса, отображение времени не изменится)
		CREATE TABLE datetime_table (datetime_field DATETIME);
		SET @@session.time_zone="+00:00"; -- сбрасываем часовой пояс в MYSQL
		INSERT INTO datetime_table VALUES("2022-06-16 16:37:23");
		SET @@session.time_zone="+03:00"; -- меняем часовой пояс в MYSQL
		SELECT * FROM datetime_table;                                       #=> 2022-06-16 16:37:23
TIMESTAMP - Хранит значение даты и времени в виде ГГГГ-MM-ДД ЧЧ:ММ:СС.  от 1970-01-01 00:00:01 до 2038-01-19 03:14:07    4 байта
	(При выборках отображается с учётом текущего часового пояса, его можно задать в настройках операционной системы, где работает MySQL, в глобальных настройках MySQL или в конкретной сессии)
	(В базе данных при создании записи с типом TIMESTAMP значение сохраняется по нулевому часовому поясу)
		CREATE TABLE timestamp_table (timestamp_field TIMESTAMP);
		SET @@session.time_zone="+00:00"; -- сбрасываем часовой пояс в MYSQL
		INSERT INTO timestamp_table VALUES("2022-06-16 16:37:23");
		SET @@session.time_zone="+03:00"; -- меняем часовой пояс в MYSQL
		SELECT * FROM timestamp_table;                                      #=> 2022-06-16 19:37:23

Значения DATETIME, DATE и TIMESTAMP могут быть заданы одним из следующих способов:
	Как строка в формате YYYY-MM-DD HH:MM:SS или в формате YY-MM-DD HH:MM:SS для указания даты и времени
	Как строка в формате YYYY-MM-DD или в формате YY-MM-DD для указания только даты
	При указании даты можно использовать любой знак пунктуации в качестве разделительного между частями разделов даты или времени. Также возможно задавать дату вообще без разделительного знака, слитно:
INSERT INTO date_table VALUES("2022-06-16 16:37:23");  #=> 2022-06-16 16:37:23
INSERT INTO date_table VALUES("22.05.31 8+15+04");     #=> 2022-05-31 08:15:04
INSERT INTO date_table VALUES("2014/02/22 16*37*22");  #=> 2014-02-22 16:37:22
INSERT INTO date_table VALUES("20220616163723");       #=> 2022-06-16 16:37:23
INSERT INTO date_table VALUES("2021-02-12");           #=> 2021-02-12 00:00:00

спецификация SQL 92, октябрь 97, стр. 171, раздел 6.16 определяет эти функции(работают с SELECT):
CURRENT_TIME       Время на момент оценки(-3 часа от моссковского_
CURRENT_DATE       Дата на момент оценки
CURRENT_TIMESTAMP  Дата и время на момент оценки


datetime() - Фишка sqlite3(??) Когда ставим значением столбца datetime() то в него помещается текущие дата и время(часовой пояс -3)


		4. Массивы
	https://www.postgresql.org/docs/current/functions-array.html
	[postgresql]   https://postgrespro.ru/docs/postgrespro/9.6/arrays  https://postgrespro.ru/docs/postgrespro/9.6/functions-array  TEXT[], INT[] ...  - массивы
SELECT * FROM film WHERE ARRAY['Trailers', 'Deleted Scenes'] <@ special_features  #=> 
SELECT * FROM film WHERE 'Deleted Scenes' = ANY(special_features) AND 'Behind the Scenes' != ALL(special_features)     #=> вроде такой синтаксис лучше

	UNNEST - создает новые строки из массива(была одна строка массив, слало много строк по числу элементов массива и так каждый массив, повторы не убираются)
SELECT UNNEST(special_features) AS feature FROM film 

SELECT GENERATE_SERIES(2, 100) AS nums                           #=> Создает столбец чисел от 2х до 100
generate_series('2005-05-24', '2005-06-02', interval  '1 day')   #=> с датами и заданным интервалом 

SELECT product_id, product_name, quantity_in_stock, GENERATE_SERIES(1, quantity_in_stock) AS n FROM products  #=> используем для размножения строк в зависимости от цифры в quantity_in_stock

select 0, '-' from generate_series(1,10)                         -- можно использовать как изначальные данные

ARRAY[1,4,3] @> ARRAY[3,1,3]                        #=> t   Содержит ли первый массив второй(каждый элемент второго массива равен какому-то элементу первого массива)
ARRAY[2,2,7] <@ ARRAY[1,7,4,2,6]                    #=> t   Содержитcя ли первый массив во втором
( (ARRAY_1 @> ARRAY_2) AND (ARRAY_1 <@ ARRAY_2) )   #=> Быстрый способ сравнить два массива(но не учитывает разные количесва одинаковых элементов)

SELECT city_name FROM stations WHERE city_name LIKE ANY(ARRAY['A%','E%','I%','O%','U%'])   -- соответсвие любому в массиве



				1. SELECT  -  выбирает данные, удовлетворяющие заданным условиям

SELECT "Hello world"                                              #=> "Hello world"  можно выводить данные не только из таблиц базы данных, но и произвольные литералы
SELECT (5 * 2 - 6) / 2 AS Result;                                 #=> 2 можно выводить результаты арифметических действий, тут в столбец Result
	(PostgreSQL чтобы название столбца сохраняло регистр он должен быть в "")

SELECT * FROM Cars                                                #=> выбрать строки всех(*) столбцов из таблицы "Cars"
SELECT Id, FirstName FROM Customers                               #=> выбрать строки столбцов "Id" и "FirstName" из таблицы "Customers"  (можно выбирать столбцы в любом порядке)

SELECT *, 'US' AS location FROM ussales                           #=> если нужно добавить новый столбец в запросе


	AS псевдонимы(алиасы)(могут содержать до 255 знаков) таблиц и столбцов: позволяет использовать псевдонимом таблицы или столбца, чтоб не писать длинное название
SELECT "Строка" AS String                                         #=> литерал "Строка" в столбце с псевдонимом String
SELECT member_id, member_name AS Name FROM FamilyMembers          #=> выводим 2 поля, при этом 2е с другим названием при помощи псевдонима
SELECT member_id, member_name Name FROM FamilyMembers             #=> тоже самое только без AS тк писать его не обязательно, можно просто через пробел
SELECT * FROM Customers C WHERE C.Id < 5                          #=> определяем и потом используем псевдоним таблицы(C для Customers) при работе с WHERE 
SELECT name AS 'Имя' FROM people                                  #=> [MySQL ?] псевдоним колонки name русским шрифтом


	Встроенная функция это реализованный в СУБД кусок кода, выполняет преобразования строковых, числовых итд данных в запросах. Может иметь 0 или несколько аргументов. Возвращает какой-то литерал.
SELECT UPPER("Hello world") AS upper_string;                      #=> "HELLO WORLD". Функция UPPER возвращает строку в верхнем регистре
SELECT LOWER('SQL Academy') AS lower_string;                      #=> "sql academy"  Функция LOWER возвращает строку в нижнем регистре
SELECT YEAR("2022-06-16") AS year;                                #=> 2022           Функция YEAR/MONTH/DAY/HOUR/MINUTE возвращает год/месяц/... для указанной даты
SELECT EXTRACT(MONTH FROM payment_date) AS month FROM payment     #=> [postgresql]  Для timestamp without time zone
SELECT INSTR('sql-academy', 'academy') AS idx;                    #=> 5              Функция INSTR поиск подстроки в строке, возвращая позицию её первого символа(отсчёт начинается с единицы)
SELECT LENGTH('sql-academy') AS str_length;                       #=> 11             Функция LENGTH возвращает длину указанной строки
SELECT LEFT('sql-academy', 3);                                    #=> "sql"          Функция LEFT возвращает заданное количество крайних левых символов строки
SELECT RIGHT('XYZ', - 1)                                          #=> 'YZ'           Обрезка с отрицательным индексом соотв тут оставляем все символы справа кроме первого

	Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы(обязательны псевдонимы). При этом функция выполняет преобразования для каждой строки отдельно.
SELECT LENGTH(name) AS fullname_length FROM FamilyMembers;                         #=> выведет столбец с длинами соотв имен из столбца name, тут псевдоним обязателен
SELECT CONCAT(prefix, '-', first, '+', last, 'вася', suffix) AS title FROM names   #=> объединение строковых значений столбцов в один столбец с добавлением доп строчных элементов
SELECT CONCAT_WS(' ', prefix, first, last, suffix) AS title FROM names             #=> тоже самое что и выше, но если между значениями нужен одинаковый элемент(тут пробел)
SELECT first_name || ' ' || last_name AS full_name FROM rentals                    #=> [postgresql ??] тоже что и 2 выше
SELECT REPEAT(name, 3) AS name FROM monsters                                       #=> REPEAT(стобец, число повторений) - повторяет строковое значение.
SELECT REVERSE(chars) AS chars FROM monsters                                       #=> реверсирует строку
SELECT SPLIT_PART(chars, ',', 1) AS char FROM monsters                             #=> разбивает строку chars по ','(тут) и выбирает 1й(тут) из разбитых кусков(только для PostgreSQL ??)
SELECT INITCAP(name) AS shortlist FROM elves                                       #=> capitalize name
SELECT CAST(id AS TEXT) AS textid FROM monsters;                                   #=> преобразование типов данных(тут INTEGER в TEXT)  
SELECT hits::FLOAT / at_bats AS batting_average FROM yankees                       #=> [postgresql] преобразование типов данных(тут INTEGER в FLOAT)
SELECT (hits::FLOAT/at_bats)::TEXT AS batting_average FROM yankees                 #=> [postgresql] преобразование типов данных
SELECT LEAST(compasses, gears, tablets) AS small FROM some                         #=> [postgresql ??] выбирает наименьшее из значений
SELECT GREATEST(1, 2, 3)                                                           #=> [postgresql ??] выбирает наибольшее из значений(тут 3)

	Операции над результатом функции - тк каждая функция возвращает литерал, то её результат также можно использовать в дальнейших расчётах и преобразованиях при помощи функций.
SELECT UPPER(LEFT('sql-academy', 3)) AS str;                                       #=> "SQL"          выполняем UPPER над результатом функции LEFT
SELECT CONCAT(UPPER(LEFT(name,1)), LOWER(RIGHT(name,LENGTH(name)-1))) FROM some    #=> capitalize name

	Обрезка дат в [postgresql]  DATE_TRUNC(field, source [, time_zone ])
	(Значения для обрезки: microseconds milliseconds second minute hour day week month quarter year decade century millennium)
SELECT DATE_TRUNC('hour', timestamp '2020-06-30 17:29:31');                        #=> 2020-06-30 17:00:00  - все дальше часа будет нулями
SELECT DATE_TRUNC('hour', timestamp with time zone '2020-06-30 17:29:31+00')       #=> 2020-07-01 03:00:00+10
SELECT DATE_TRUNC('month', created_at)::DATE AS date FROM posts GROUP BY date      #=> реальный пример с переводом в дату в конце и группировкой по дате(2022-10-01)

	ROUND(22.29, 1) - 1й параметр флоат число, 2й число знаков до которых будет округление(без 2го параметра округляет до целого)
SELECT ROUND(22.29, 1);                                                                         #=> 22.3
SELECT ROUND(22.29, -1)                                                                         #=> 20
SELECT ROUND(j.salary)::FLOAT AS average_salary FROM job GROUP BY j.job_title                   #=> [PostgreSQL] округление и преобразование во флоат(из такого 0.29e0)
SELECT ROUND(val::NUMERIC, 2)::FLOAT AS valround FROM float8                                    #=> [PostgreSQL] округление до 2х знаков необходимо переводить в NUMERIC если есть параметр(2) и ошибка

	TO_CHAR [PostgreSQL ??] - перевод в строку с определенным числом нулей после точки и еще всяким(тут символ %)
TO_CHAR(num, 'FM999990.0%')

	Регулярные выражения:
SELECT city_name FROM stations WHERE city_name ~ '^[AEIOU]'                        -- ищем соотв значения(тут с первой буквой из указанных)
	SUBSTRING(имя_столбца FROM 'регулярное_выражение')   вырезать из строки по шаблону
SELECT SUBSTRING(greeting FROM '#\d+') AS user_id FROM greetings                   #=> Bienvenido 45454545 tal #470815 BD. WA470815   ->  #470815
	REGEXP_REPLACE(строка, регулярка, элемент замены, позиция(число, не обязательно))  -  заменить элементы строки
SELECT REGEXP_REPLACE('1, 4, и 10 числа', '\d', '@') FROM dual                     #=> '@, @, и @@ числа' [ORACLE PL/SQL] меняем любую цифру на @ (само меняет все цифры)
SELECT REGEXP_REPLACE('1, 4, и 10 числа', '\d','@','g')  FROM dual                 #=> '@, @, и @@ числа' [postgresql] меняем любую цифру на @ (само меняет только 1й, нужно добавить 'g')
SELECT REGEXP_REPLACE('John Doe', '(.*) (.*)', '\2, \1');                          #=> 'Doe, John'  

	REGEXP_SPLIT_TO_TABLE(имя_столбца, регулярное_выражение) - сделать таблицу из подстрок разбитой по условию строки
SELECT REGEXP_SPLIT_TO_TABLE(str, '[aeiou]') AS results FROM random_string         #=>  разбиваем строку по гласным(с их удалением) в столбец таблицы   

	DISTINCT (исключение дубликатов) - позволяет исключить одинаковые значения в выводе, если нам нужны только уникальные
SELECT DISTINCT class FROM Student_in_class;                      #=> выбираем все варианты численности классов(class), тк нас интересуют именно варианты, а не конкретные классы, то дубликаты исключаем
SELECT DISTINCT first_name, last_name FROM User;                  #=> применяя к нескольким столбцам исключаются только те строки в которых значения строк одинаковы во всех выбранных стобцах

	DISTINCT ON (исключение дубликатов по столбцу) (возможно придется использовать в подзапросе, чтоб обработать рез потом)
SELECT DISTINCT ON(team) * FROM employees ORDER BY birth_date DESC  #=> выбирает уникальные значения по столбцу, отсортированные по дате, тоесть выбраны эти уникальные с самой большой датой
SELECT DISTINCT ON(user_id, video_id) user_id, video_id FROM user_playlist  #=> по нескольким столбцам

	LIMIT - пишется в самом конце запроса, позволяет извлечь определённый диапазон записей из одной или нескольких таблиц.
	(Оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP)
SELECT capital FROM countries WHERE continent IN ('Africa', 'Afrika') AND country LIKE 'E%' ORDER BY capital LIMIT 6   #=> выводит токо 6 певых строк
SELECT * FROM Company LIMIT 2, 3;                                                                                      #=> выводит строки с 3й по 5ю(1я цифра число пропущеных строк, 2я число строк)
SELECT * FROM Company LIMIT 3 OFFSET 2;                                                                                #=> альтернативный синтаксис того что выше
SELECT * FROM Company OFFSET 2;                                                                                        #=> выбираем все кроме 2х первых строк

	ROW_NUMBER() OVER(ORDER BY SUM(имя_колонки) DESC) - вывести новую колонку порядковых номеров по убыванию относительно значений указанной колонки, которые заполняются автоматически
SELECT ROW_NUMBER() OVER(ORDER BY points DESC) AS rank FROM people;
SELECT ROW_NUMBER() OVER(ORDER BY SUM(points) DESC) AS rank FROM people GROUP BY some;

	ROW_NUMBER() OVER(PARTITION BY store_id ORDER BY count(*) DESC, category.name) AS category_rank
#=> разбивка ранга по значениям столбца(когда новое значения ранг начинается снова с 1)  ???

	DATEDIFF(interval, from, to): interval - дни/месяцы/годы. от даты from до даты to
SELECT DATEDIFF(DAY, OrderTime, DeliveryTime) AS AvDelTime FROM Orders           #=> тут (day, OrderTime, DeliveryTime) расчет количества дней между OrderTime и DeliveryTime

	TIMESTAMPDIFF(SECOND, time_out, time_in) - среднее время в секундах между time_out и time_in
SELECT plane, TIMESTAMPDIFF(SECOND, time_out, time_in) AS time FROM Trip         #=> время полета


	WHERE (где): условный оператор, выводит только те строки которые соответсвуют условию (в сравнении можно использовать = > < >= <= != <>)(посл это тоже знак "не равно")
SELECT * FROM Cars WHERE price > 1000                             #=> выбрать из таблицы "Cars" те строки всех столбцов, где значение в столбце "price" больше 1000
SELECT * FROM Orders WHERE DeliveryTime < '2013-06-20'            #=> выбрать из таблицы "Orders" те строки всех столбцов, где значение даты в столбце "DeliveryTime" меньше чем 20.06.2013
SELECT * FROM students WHERE tuition_received = false             #=> c Boolean значениями false в столбце tuition_received
SELECT * FROM Student WHERE first_name = "Grigorij";              #=> выбираем где значение столбца first_name это "Grigorij"
SELECT * FROM Student WHERE YEAR(birthday) > 2000;                #=> выбираем где год из столбца birthday больше 2000

	LIKE (поиск): условный оператор позволяет нам искать текст, соответствующий части строки поиска. Например, поиск по имени LIKE 'Jan%' будет соответствовать Jane и Janet, но не Jack. 
	Символ % соответствует любому количеству(>=0) любых символов. Пр 'begin%end' 'text%' '%text' 
	символ _ соответствует одному неизвестному символу. Пр 's_me' '_ext'
SELECT * FROM Customers WHERE LastName LIKE 'A%'                  #=> Выберем те строки всех столбцов из "Customers", значение столбца "LastName" в которых начинается с буквы A.
SELECT name, email FROM Users WHERE email LIKE '%@hotmail.%'      #=> выбираем где значение колонки почта содержит @hotmail.
SELECT * FROM Some WHERE fild LIKE '_ext                          #=> выбираем где в колонке fild стоит ext с любой первой буквой

	ESCAPE-символ (экранирование): используется назначаемый символ для экранирования специальных символов (% и \). Чтобы они являлись обычными символами
SELECT job_id FROM Jobs WHERE progress LIKE '3!%' ESCAPE '!';     #=> нужен прогресс задач в '3%'(три процента). Экранируем '%' назначая для этого символ '!' и ставя его перед

	OR|AND|XOR (или|и|исключающее или): логические операторы позволяют объединять несколько условий. XOR - только одно из сравниваемых значений должно быть истинно, а другое должно быть ложно
	(XOR похоже нет в постгресс)
SELECT * FROM Customers WHERE FirstName LIKE 'A%' OR Id < 10                          #=> выбираем из таблицы строки, где значение столбца "FirstName" начинается с буквы A или "Id" меньше 10
SELECT * FROM Orders WHERE OrderTotal > 100 AND OrderTime > '2012-10-12'                           #=> ... где значение одного столбца больше 100 и другого больше даты
SELECT * FROM Orders WHERE OrderTotal > 300 OR (OrderTotal > 200 AND OrderTime > '2012-11-15')     #=> сложное условие, приоритет обозначаем скобками(как и везде)
SELECT * FROM travelers WHERE country <> 'Canada' AND country <> 'Mexico' AND country <> 'USA'     #=> пример с text/varchar

	IS NULL (является значением null): лпозволяет узнать равно ли проверяемое значение NULL, тк some = NULL - не работает.
SELECT * FROM Teacher WHERE middle_name IS NULL;                  #=> выводит все где значением столбца middle_name является null 
SELECT id FROM orders WHERE date IS NOT NULL                      #=> не является null

	BETWEEN (BETWEEN min AND max): логический оператор позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами значения min и max
SELECT * FROM Orders WHERE OrderTotal BETWEEN 100 AND 200              #=> выбрать из таблицы "Orders" те строки всех столбцов, где значение в столбце "OrderTotal" между 100 и 200
SELECT * FROM Orders WHERE OrderTotal BETWEEN 100 AND 200 AND id > 10  #=> тоже но с доп условием

	IN (входит): логический оператор позволяет узнать входит ли проверяемое значение столбца в список определённых значений
SELECT * FROM FamilyMembers WHERE status IN ('father', 'mother');      #=> выбрать все где значение столбца status соответсует 'father' или 'mother'

	NOT (не является): логический оператор отрицания, так же меняет значение логических операторов и операторов сравнения на противоположный
SELECT * FROM students WHERE NOT tuition_received                            #=> c Boolean значениями в с толбце tuition_received должно быть false(отрицание true) тут именно false а не null
SELECT * FROM Trip WHERE plane = 'Boeing' AND NOT town_from = 'London';      #=> выводит где самолет боинг а город отправления не лондон.
SELECT * FROM travelers WHERE country NOT IN ('Canada', 'Mexico', 'USA')     #=> выбираем все, где в значениях столбца "country" не стоит чтото из 'Canada', 'Mexico', 'USA'


	Полнотекстовый поиск [Postgres]   https://supabase.com/docs/guides/database/full-text-search
	TO_TSVECTOR() - Преобразует ваши данные в доступные для поиска «токены».  select to_tsvector('green eggs and ham')  #=>  'egg':2 'green':1 'ham':4
	TO_TSQUERY() - Преобразует строку запроса в «токены» для соответствия. Этот шаг преобразования важен, потому что мы хотим получить «нечеткое соответствие» 
	@@  - символ «совпадения» для полнотекстового поиска. Он возвращает любые совпадения между to_tsvector результатом и to_tsquery результатом
SELECT * FROM books WHERE title = 'Harry'                                                   #=> Символ равенства очень «строгий» в отношении того, что ему соответствует
SELECT * FROM books WHERE TO_TSVECTOR(title) @@ TO_TSQUERY('Harry')                         #=> найти все что содержит подстроку 'Harry' в столбце title
SELECT * FROM books WHERE TO_TSVECTOR(description || ' ' || title) @@ TO_TSQUERY('little')  #=> поиск сразу в нескольких столбцах(предварительно объединяет столбцы, потому добавим пробел)
SELECT * FROM books WHERE TO_TSVECTOR(description) @@ TO_TSQUERY('little & big')            #=> поиск сразу 2х(обоих) слов(объединяем при помощи символа &)
SELECT * FROM books WHERE TO_TSVECTOR(description) @@ TO_TSQUERY('little | big')            #=> поиск одного из слов(объединяем при помощи символа |)
SELECT * FROM books WHERE TO_TSVECTOR(description) @@ TO_TSQUERY('big <-> dreams')          #=> поиск 2х слов идущих один за другим
SELECT * FROM books WHERE TO_TSVECTOR(description) @@ TO_TSQUERY('year <2> school')         #=> поиск 2х слов идущих в пределах 2х слов между ними
SELECT * FROM books WHERE TO_TSVECTOR(description) @@ TO_TSQUERY('big & !little')           #=> отрицание - одно слово содержится а другое обязательно не содержится
SELECT * FROM product WHERE TO_TSVECTOR('english', product.name) @@ TO_TSQUERY('english', 'awesome')   #=> указание языка или поиск сразу по 2м колонкам ?



	ORDER BY (порядок/сортировка): позволяет вывести по определенному(по умолчанию от наименьшего) порядку(например значений некого столбца)
SELECT name FROM Company ORDER BY name;                                #=> сортируем строки по значениям столбца name
SELECT * FROM Orders WHERE Time > '2013-01-15' ORDER BY Time           #=> (ORDER BY пишется после WHERE)отображаем порядок строк по значениям столбца "OrderTime"
SELECT * FROM Orders ORDER BY DeliveryTime DESC                        #=> добавляя в конце DESC получаем порядок по убыванию(ASC - по возрастанию, значение по умолчанию)
SELECT * FROM Orders ORDER BY OrderTime DESC, OrderTotal ASC           #=> сортируем по 2м столбцам(через запятую) при равенстве значений в 1м, сортирует по 2му итд(Даже если оба DESK пишем оба раза)
SELECT * FROM companies ORDER BY 4                                     #=> используем номер колонки вместо названия(сортируем по 4й колонке)

https://www.geeksforgeeks.org/how-to-custom-sort-in-sql-order-by-clause/  - сортировка с условным оператором case


	GROUP BY (группировка функций/значений): возврат значений или функций для нескольких подмножеств данных(например вывод средней суммы по годам из столбца дат)
		(Мы какбы группируем колонки по подтипам, группируя все одинаковые значения в подтип(в одну строку), соттв число подкгуп равно числу всех значений без повторов)
SELECT home_type FROM Rooms GROUP BY home_type                                     #=> выдаст все типы значений в home_type сгруппированные(объединенные/нет одинаковых) по значениям home_type
SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type            #=> выводим группы значений home_type и фунуцию среднего(AVG) всех значений для каждой из этих групп
SELECT YEAR(OrderTime) yr, SUM(OrderTotal) st FROM Orders GROUP BY YEAR(OrderTime) #=> При помощи GROUP BY группируем по годам из OrderTime(1й солбец), соотв сумма будет тоже за каждый из годов(2й столбец).
SELECT * FROM Ord GROUP BY YEAR(OrdTime), MONTH(OrdTime) ORDER BY YEAR(OrderTime)  #=> Группировка по нескольким колонкам, для обобщения в одну группу одинаковыми дожны быть значения во всех этих колонках

	ROLLUP(col1, col2, coln) [Postgres  ??]  - группировка по разному коллич полей сразу(сначала по всем, потом по всем кроме последнего, потом по всем кроме последних 2х ..итд, по первому)
SELECT name, EXTRACT(YEAR FROM date) AS year, EXTRACT(MONTH FROM date) AS month, EXTRACT(DAY FROM date) AS day, SUM(price * count) AS total FROM products GROUP BY ROLLUP(product_name, year, month, day) 

	GROUPING SETS() [Postgres  ??]  - группировка по разному коллич полей сразу по кастомным наборам
SELECT name, EXTRACT(YEAR FROM date) AS year, EXTRACT(MONTH FROM date) AS month, EXTRACT(DAY FROM date) AS day, SUM(price * count) AS total FROM products
GROUP BY GROUPING SETS ((product_name, year), (product_name, year, month), (product_name, year, month, day), (product_name))


Агрегатная функция – это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение. 
Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT(*)

	COUNT(имя_столбца) - агрегатная функция позволяет считать элементы
SELECT COUNT(*) FROM Orders                                                              #=> считает все строки в таблице "Orders"
SELECT home_type, COUNT(*) AS amount FROM Rooms GROUP BY home_type ORDER BY amount DESC  #=> выводим колич жилья каждого типа в порядке по убыванию от этого количества

	SUM(имя_столбца) - агрегатная функция суммирует значения заданного столбца
SELECT SUM(OrderTotal) FROM Orders WHERE OrderTime > '2013-01-01'                        #=> выводим сумму тех значений столбца OrderTotal в которых в столбце OrderTime значение больше указанного

	MIN/MAX(имя_столбца) (минимум/максимум): возвращают наименьшее или наибольшее значение для указанного столбца.
SELECT MIN(OrderTime) AS minDate, MAX(OrderTime) AS maxDate FROM Orders                            #=> выводит в 2х однострочных колонках под новыми именами самую маленькую и самую большую даты
SELECT YEAR(OrderTime) AS OYear, MAX(OrderTotal) AS maxOT FROM Orders GROUP BY YEAR(OrderTime)     #=> выводит максимальные значения колонки OrderTotal по годам(сгруппированные по годам)
SELECT room_id, MAX(end_date) AS last_end_date FROM Reservations GROUP BY room_id                  #=> самые позние даты выезда сгруппированные по номерам комнат

	AVG/STDEV(имя_столбца) (среднее значение/стандартное отклонение): считает среднее значение столбца
SELECT YEAR(OrderTime) AS OYear, AVG(OrderTotal) AS AvDelTime FROM Orders GROUP BY YEAR(OrderTime) #=> среднее значение столбца OrderTotal за каждый год(группируем по годам)
SELECT plane, AVG(TIMESTAMPDIFF(SECOND, time_out, time_in)) AS time FROM Trip GROUP BY plane       #=> среднее время полета по моделям самолетов

	RANK() [PostgreSQL] Функция RANK()присваивает ранг каждой строке в разделе результирующего набора.
SELECT sale, RANK() OVER(ORDER BY sale DESC) AS sale_rank FROM sales GROUP BY sale                   #=> создаем колонку рангов цен у наибольшей(DESC) лучший ранг(1й) у одинаковых одинаковый ранг.
SELECT sale, RANK() OVER(ORDER BY sale DESC, some DESC) AS sale_rank FROM sales GROUP BY sale        #=> ранг по 2м полям, если 1е равно использует 2е

	Медианное значение столбца(постгре??)
SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY score) AS median FROM result                      # больше подходит для целых чисел
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY some) AS median FROM result                       # больше подходит для непрерывных значений ??

	ARRAY_AGG(column) [PostgreSQL ??] создание массива из сгруппированных значений столбца
SELECT name, ARRAY_AGG(rating) AS total_rentals FROM customer GROUP BY name                          #=> группируем по имени, создавая массив всех рэйтингов к нем относящихся
	ARRAY_AGG(column ORDER BY column2) [PostgreSQL ??] создание массива из сгруппированных значений столбца с сортировкой внутри массива в том числе по другому столбцу
SELECT ARRAY_AGG(name ORDER BY id DESC) AS names FROM students GROUP BY subject                      #=> группируем имена в массив, где ини будут порядке по id

	HAVING (наличие): фильтрует группы по условию, чемто похоже на WHERE, нужен для того чтоб фильтровать после агрегирования(суммы, подсчет итд) для GROUP BY
	(раполагается после GROUP BY но до ORDER BY)
SELECT CustomerId, COUNT(*) AS Count FROM Orders GROUP BY CustomerId HAVING COUNT(*) > 5       #=> считает количество заказов, размещенных каждым клиентом, а затем отфильтрует только клиентов с более чем 5
SELECT home_type, AVG(price) AS avg_price FROM Rooms GROUP BY home_type HAVING avg_price > 50  #=> средняя цена сгруппированная по тем типам домов где эта средняя цена больше 50
SELECT home_type, MIN(price) AS min_price FROM Rooms WHERE has_tv = True GROUP BY home_type HAVING COUNT(*) >= 5; #=> выводит только для тех типов домов с телевизором, которых есть >= 5
SELECT name AS total_rentals FROM customer GROUP BY name HAVING 'NC-17' != ALL(ARRAY_AGG(f.rating))               #=> используем HAVING с колонкой которую не выводим

	HAVING EVERY   -  аналог ALL ???.  тоесть где все сгруппированные значения соотв условию
SELECT customer_id FROM orders GROUP BY customer_id HAVING EVERY(delivery_date IS NULL) ORDER BY 1 DESC



	таблица.столбец (прим Customers.Id): позволяет при работе с несколькими таблицами выбирать столбцы из определенных
SELECT Customers.Id FROM Customers WHERE Customers.id < 5 

	Перечисление таблиц через запятую - все данные одной таблицы для каждого элемента другой и наоборот, те будет огромная таблица хз чего
SELECT * FROM people, toys 


	JOIN - многотабличные запрсы(позволяет делать выборку из нескольких таблиц объединяя их в запрсе - позволяют нам «соединять» строки нескольких таблиц вместе). Соединение бывает: 
		внутренним INNER (по умолчанию) 
		внешним OUTER, при этом внешнее соединение делится на левое LEFT, правое RIGHT и полное FULL

	ON - оператор после кторого пишется условие о том как именно записи из разных таблиц должны находить друг друга(как они соответствуют друг другу)

	INNER JOIN (внутреннее соединение): INNER писать не обязательно тк это значение по умолчанию
	Внутреннее соединение —  находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем самым образуя новую таблицу, содержащую поля из первой и второй исходных таблиц.
	Если нашем условии указано равенство полей A.good_id и B.id, то при внутреннем соединении в итоговой выборке окажутся только записи, где в обоих таблицах есть одинаковое значения в good_id и id.
SELECT * FROM Customers INNER JOIN Orders ON Orders.NameId = Customers.Id                       #=> выбираем все строки 2х таблиц в которых  Orders.NameId = Customers.Id, таблиц Customers и Orders 
SELECT products.*, companies.name AS name FROM products JOIN companies ON products.company_id = companies.id      #=> выбираем из 1й таблицы все, а из 2й одну колонку
SELECT family_member, member_name, amount * unit_price AS price FROM Payments INNER JOIN FamilyMembers ON Payments.family_member = FamilyMembers.member_id
#=> тут колонки family_member, amount, unit_price - из таблицы Payments; а колонка member_name - из таблицы FamilyMembers (1)
SELECT Class.name, Stud_in_class.student, Student.first_name FROM Class JOIN Stud_in_class ON Class.id = Stud_in_class.class JOIN Student ON Stud_in_class.student = Student.id   #=> объединение 3х таблиц

	(АЛЬТЕРНАТИВА)Перечисление таблиц через запятую вместо INNER JOIN и WHERE вместо ON
SELECT family_member, member_name FROM Payments, FamilyMembers WHERE Payments.family_member = FamilyMembers.member_id   #=> тот же запрос что и выше (1)
SELECT people.*, toys.toy_count FROM people, toys WHERE people.id = toys.people_id

	INNER JOIN + WHERE
SELECT * FROM Customers C INNER JOIN Orders O ON O.CustomerId = C.Id WHERE O.OrderTotal > 200   #=> INNER JOIN + псевдонимы + WHERE
SELECT good_name FROM Goods JOIN Payments ON Payments.good = Goods.good_id JOIN FamilyMembers ON Payments.family_member = FamilyMembers.member_id WHERE status = 'son'
#=> условие WHERE пишется после всего многотабличного запроса. Если выводится колонка только 1й таблицы указывать через точку не обязательно.

	INNER JOIN + USING (вместо ON и сравнения) + AND (дополнительная выборка в присоединяемой таблице, удобно для многотабличных джойнов)
SELECT film_id, title, popularity FROM film
JOIN film_category USING (film_id)
JOIN category ON film_category.category_id = category.category_id AND name = 'Children'
JOIN inventory USING (film_id)

	INNER JOIN + GROUP BY 
SELECT people.*, COUNT(*) AS toy_count FROM toys JOIN people ON people.id = toys.people_id GROUP BY people.id            #=> с использованием функции для таблицы toys
SELECT Reservations.room_id, AVG(Reviews.rating) AS avg_score FROM Reservations JOIN Reviews ON Reservations.id = Reviews.reservation_id GROUP BY Reservations.room_id
#=> выбираем Reservations.room_id и средние значения Reviews.rating для каждого Reservations.room_id при помощи группировки по Reservations.room_id из объединенных таблиц Reservations и Reviews


	OUTER JOIN (внешнее соединение): может быть трёх типов: левое LEFT, правое RIGHT и полное FULL. По умолчанию оно является полным.
	Оно обязательно возвращает все строки одной таблицы (LEFT, RIGHT) или двух таблиц (FULL)

	LEFT OUTER JOIN (внешнее левое соединение): возвращает все значения из левой таблицы, соединённые с соответствующими значениями из правой таблицы, если они удовлетворяют условию соединения
	( или заменяет их на NULL те что не удовлетворяют )
SELECT Timepair.id 'timepair.id', start_pair, end_pair,                                       #=> Timepair.id 'timepair.id' вариант псевдономи(только для MySQL ???)
    Schedule.id 'schedule.id', date, class, number_pair, teacher, subject, classroom
FROM Timepair LEFT JOIN Schedule ON Schedule.number_pair = Timepair.id;
#=> В выборку попали все строки из левой таблицы, дополненные данными из правой там где есть Schedule.number_pair = Timepair.id, где нет в колонки правой таблицы проставлены NULL

SELECT first_name, last_name, COUNT(Schedule.id) AS amount_classes FROM Teacher LEFT JOIN Schedule ON Teacher.id = Schedule.teacher GROUP BY Teacher.id      #=> с функцией

	Получение данных, относящихся только к левой таблице(которые из правой дополнены значениями NULL):
SELECT поля_таблиц FROM левая_таблица LEFT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ WHERE правая_таблица.ключ IS NULL


	RIGHT OUTER JOIN (внешнее правое соединение): тоже что и левое только все значения возвращаются из правой а из левой только соотв условию или иначе NULL

	FULL OUTER JOIN (внешнее полное соединение): Соединение, которое выполняет внутреннее соединение записей и дополняет их левым внешним соединением и правым внешним соединением
		1. Формируется таблица на основе внутреннего соединения (INNER JOIN)
		2. В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN)
		3. В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN)
	Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует
SELECT поля_таблиц FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ

SELECT s.product_id AS product_id, s.quantity AS sale_qty, r.quantity AS return_qty, s.date AS date
FROM sales AS s FULL OUTER JOIN returns AS r ON s.product_id = r.product_id AND s.date = r.date       #=> объединение по соответсвии 2х полей


	Получение данных, не относящихся к левой и правой таблицам одновременно (обратное INNER JOIN):
SELECT поля_таблиц FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ WHERE левая_таблица.ключ IS NULL OR правая_таблица.ключ IS NULL


	CROSS JOIN LATERAL - вывод новых строк из одной строки
SELECT s.results FROM strings
CROSS JOIN LATERAL unnest(string_to_array(string, ' ')) AS s(results)  #=> тут results название столбца на выходе а s - хз что (мб s(results) просто имя те скобки не функциональны ??)



	Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.

	1. Подзапрос возвращающий 1 строку одного столбца(скалярный подзапрос)
	(может использоваться в различных частях основного SQL запроса, но чаще всего он используется в условиях ограничений выборки с помощью операторов сравнения =, <>, >, <)
SELECT (SELECT name FROM company LIMIT 1) AS company_name                                                       #=> вывод единственного значения (названия компании)
SELECT * FROM FamilyMembers WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers)                          #=> вывод самых молодых
SELECT * FROM Reservations WHERE Reservations.room_id = (SELECT id FROM Rooms ORDER BY price DESC LIMIT 1)      #=> список всех бронирований самой дорогой комнаты
SELECT Users.* FROM Users JOIN Rooms ON Rooms.owner_id = Users.id WHERE price = (SELECT MAX(price) FROM Rooms)  #=> в многотабличном запросе

	2. Подзапросы с несколькими строками и одним столбцом(его нельзя просто использовать с операторами сравнения тк возвращает много строк)
	ALL - можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом. Вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.
SELECT 200 > ALL(SELECT price FROM Rooms)                                                                    #=> все ли комнаты дешевле чем 200
SELECT DISTINCT name FROM Users JOIN Rooms ON Users.id = Rooms.owner_id WHERE Users.id <> ALL (SELECT DISTINCT user_id FROM Reservations)
	IN - проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использовать подзапрос, возвращающий несколько строк с одним столбцом.
SELECT id, name FROM departments WHERE id IN (SELECT department_id FROM sales WHERE price > 98)              #=> так как используется IN то в подзапросе должен быть 1 стобец
SELECT good_name FROM Goods WHERE good_id NOT IN (SELECT good FROM Payments)                                 #=> NOT IN
	ANY - имеет схожие поведение c IN но возвращает TRUE(те работает через операторы сравнения), если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.
SELECT * FROM Users WHERE id = ANY (SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150)                  #=> найдёт пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150

	3. Многостолбцовые подзапросы - возвращающими несколько столбцов и несколько строк (производные таблицы)
SELECT * FROM Reservations WHERE (room_id, price) IN (SELECT id, price FROM Rooms)                           #=> попарно сравнивает значения в основном запросе со значениями в подзапросе
SELECT * FROM Rooms WHERE (has_tv, has_internet) IN (SELECT has_tv, has_internet FROM Rooms WHERE id=11)     #=> по одной конкретной строке

	4. Коррелированные подзапросы - ссылаются на один или несколько столбцов основного запроса(зависимые, все прошлые 3 варианта были независимы от остального запроса)
	(он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки, которая может быть включена в окончательный результат)
	(использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если содержащий запрос возвращает много строк)
SELECT 
   FamilyMembers.member_name, 
   (SELECT MAX(Payments.unit_price) FROM Payments WHERE Payments.family_member = FamilyMembers.member_id) AS max_price 
FROM FamilyMembers
#=> Выводим для каждой строки максимум значения колонки из строки другой таблицы по соотв этих строк в значениях Payments.family_member и FamilyMembers.member_id

	Можно использовать другой запрос после FROM вместо имени таблицы
select user_id, video_id from (select user_id, video_id, count(distinct video_id) over (partition by user_id) as cnt from user_playlist) t

	Подзапрос таблицы к самой себе. Имитирует GROUP BY по полю supplier_id
SELECT DISTINCT ON(supplier_id) 
  supplier_id, 
  (SELECT COUNT(id) FROM products AS o WHERE o.supplier_id = p.supplier_id) AS total_products 
FROM products AS p
ORDER BY supplier_id DESC

	EXISTS используется в сочетании с подзапросом и считается выполненным, если подзапрос возвращает хотя бы одну строку
	(Операторы SQL, использующие условие EXISTS, очень неэффективны, поскольку подзапрос повторно запускается для КАЖДОЙ строки в таблице внешнего запроса)
SELECT * FROM customers WHERE EXISTS (SELECT * FROM orders WHERE customers.customer_id = orders.customer_id)

	Двойное условие для подзапроса(не только для EXISTS а для любого оператора)
SELECT * FROM dep WHERE EXISTS (SELECT dep_id FROM sales WHERE sales.dep_id = dep.id AND price > 98)          #=> 2е условие для позапроса через AND

	EXCEPT  - не соответсвие подзапросу
SELECT id FROM orders EXCEPT SELECT id FROM orders WHERE date IS NOT NULL 



	UNION (Объединение запросов) - объединяет запросы в одну результирующую таблицу. По умолчанию убирает повторения в результирующей таблице.
	(Не путайте операции объединения запросов с операциями объединения таблиц. Для этого служит оператор JOIN.)
	(чтобы UNION корректно сработал нужно: чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.)
SELECT DISTINCT Goods.good_name AS name FROM Goods
UNION
SELECT DISTINCT FamilyMembers.member_name AS name FROM FamilyMembers;   #=> тут в один столбец name попадут и имена членов семьи и названия товаров(будет каша но эт пример)

SELECT first_name, middle_name, last_name FROM Student 
UNION
SELECT first_name, middle_name, last_name FROM Teacher;                 #=> объединяем по столбцам ФИО строки данных учеников и учителей

	UNION ALL не убирает дубликаты

	INTERSECT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.(работает как UNION ??)

	EXCEPT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.(работает как UNION ??)



	WITH (Обобщённое табличное выражение или CTE - Common Table Expressions) - это временный набор данных, к которому можно обращаться в последующих запросах.
	(Выражение с WITH считается «временным», потому что результат не сохраняется где-либо на постоянной основе в схеме базы данных)
	(оно доступно только во время выполнения операторов SELECT, INSERT, UPDATE, DELETE или MERGE. Оно действительно только в том запросе, которому он принадлежит)
	(главная задача – улучшение читабельности, простоты написания запросов и их дальнейшей поддержки.)
WITH Aeroflot_trips AS 
	(SELECT Trip.* FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;           #=> теперь мы можем использовать временную таблицу Aeroflot_trips созданную в WITH для запроса

WITH Aeroflot_trips (aeroflot_plane, town_from, town_to) AS
    (SELECT plane, town_from, town_to FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
SELECT * FROM Aeroflot_trips;                                                      #=> с переименованием колонок

WITH Aeroflot_trips AS
    (SELECT Trip.* FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT Trip.* FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")
SELECT * FROM Don_avia_trips UNION SELECT * FROM  Aeroflot_trips;                  #=> несколько табличных выражений через запятую

WITH Aeroflot_trips AS
    (SELECT Trip.* FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT Trip.* FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia"),
    Aeroflot_Don
    (SELECT * FROM Don_avia_trips UNION SELECT * FROM  Aeroflot_trips)
SELECT * FROM Aeroflot_Don WHERE id > 10                                           #=> 3е выражение использует для запроса 1е и 2е



	CASE (условный оператор/условная логика) - результат обычно представляет собой значение какогото нового выводимого столбца     
SELECT 
 name,
 CASE
   WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (10, 11) THEN "Старшая школа"
   WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (5, 6, 7, 8, 9) THEN "Средняя школа"
   ELSE "Начальная школа"
 END AS stage     #=>   возвращаем в новую колонку stage значения в зависимости от условия
FROM Class        #=>   несколько условий(если первое не срабатывает переходим ко второму итд)

SELECT 
  CASE
    WHEN SUM(number1)%2=0 THEN MAX(number1)
    ELSE MIN(number1) 
  END AS number1,
  CASE
    WHEN SUM(number2)%2=0 THEN MAX(number2)
    ELSE MIN(number2) 
  END AS number2
FROM numbers      #=>    несколько условных операторов через запятую

SELECT name,
  CASE SUBSTRING(name, 1, INSTR(name, ' '))
    WHEN 11 THEN "Старшая школа"
    WHEN 9 THEN "Средняя школа"
    ELSE "Начальная школа"
  END AS stage
FROM Class        #=>   просто стравниваем значения CASE со значениями в WHEN по одному(придется писать много условий для каждого класса)

SELECT p.name,
  COUNT(CASE WHEN d.detail LIKE '%oo%' THEN 1 ELSE 0 END) AS good,
  COUNT(CASE WHEN d.detail = 'ok'  THEN 1 ELSE 0 END) AS ok, 
  COUNT(CASE WHEN d.detail = 'bad' THEN 1 ELSE 0 END) AS bad
FROM products p
INNER JOIN details d ON p.id = d.product_id  #=> в одну строку с надфункцией



	IF (условная функция/условная логика) - IF (условное_выражение, значение_1, значение_2);
	(Если условное выражение в первом аргументе в функции IF, истинно, функция вернёт значение второго аргумента значение_1, иначе возвращается значение третьего аргумента значение_2)
SELECT IF(10 > 20, "TRUE", "FALSE");                                                          #=> "FALSE"
SELECT id, price, IF(price >= 150, "Комфорт-класс", "Эконом-класс") AS category FROM Rooms    #=> ставим значеня в колонке category в зависимости от значения колонки price
SELECT id, price, IF(price >= 200, "Бизнес-класс", IF(price >= 150, "Комфорт-класс", "Эконом-класс")) AS category FROM Rooms   #=> вложение одного IF в другой(эмуляция CASE)

	IFNULL (условная функция) - IFNULL(значение, альтернативное_значение); возвращает значение, переданное первым аргументом, если оно не равно NULL, иначе возвращает альтернативное_значение
SELECT IFNULL("SQL Academy", "Альтернатива SQL Academy") AS sql_trainer;                 

	NULLIF (условная функция) - NULLIF(значение_1, значение_2); возвращает NULL, если значение_1 равно значению_2, в противном случае возвращает значение_1(тоесть колонку для проверки ставим в 1)
SELECT NULLIF("SQL Academy", "SQL Academy") AS sql_trainer;                                   #=> <NULL>
SELECT NULLIF("SQL Academy", "Альтернатива SQL Academy") AS sql_trainer;                      #=> "SQL Academy"

	COALESCE - это специальное выражение, которое вычисляет по порядку каждый из своих аргументов и на выходе возвращает значение первого аргумента, который был не NULL.
SELECT COALESCE(NULL, NULL, 1, 2, NULL, 3)                                                    #=> 1
SELECT name, COALESCE(bonus1, bonus2, 1000000) AS bonus FROM table_name                       #=> если bonus1==NULL выбирает значение bonus2 если и оно ==NULL, тогда выбирает 1000000 

SELECT COALESCE(NULLIF(name,''), '[product name not found]') AS name FROM eusales             #=> при помощи NULLIF меняем пустые строки на NULL чтобы применить COALESCE

	[постгресс] bool_or(column = value)  Если значение равно значению столбца вернет true иначе false
select username, bool_or(role = 'internal') as internal, bool_or(role = 'admin') as admin from user_roles




				2. INSERT - позволяет нам наполнять таблицу, добавляет новые данные

	Значения можно вставлять перечислением с помощью слова VALUES, перечислив их в круглых скобках через запятую или c помощью оператора SELECT например из другой таблицы:
INSERT INTO имя_таблицы [(поле_таблицы, ...)] VALUES (значение_поля_таблицы, ...)
INSERT INTO имя_таблицы [(поле_таблицы, ...)] SELECT поле_таблицы, ... FROM имя_таблицы ...

INSERT INTO Cars (Id, Name, Price) VALUES (1, 'BMW', 10000)       #=> добавляем в столбцы(Id, Name, Price) новую строку со значениями(1, 'BMW', 10000)

	Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведёт к ошибке.
INSERT INTO Goods SELECT COUNT(*) + 1, 'Table', 2 FROM Goods;     #=> вариант задания значения ключа способом SELECT

	Во многих СУБД введён механизм его автоматической генерации. Для этого достаточно снабдить первичный ключ good_id атрибутом AUTO_INCREMENT. 
	Тогда при создании новой записи в качестве значения good_id достаточно передать NULL или 0(MySQL ??)
INSERT INTO Goods VALUES (NULL, 'Table', 2);
	PostgreSQL есть схожий механизм. Он имеет типы SMALLSERIAL, SERIAL, BIGSERIAL. Столбец с одним из них будет являться целочисленным и автоматически увеличиваться при добавлении новой записи
	CREATE TABLE Goods ( good_id SERIAL ... );
INSERT INTO Goods (good_name, type) VALUES ('Table', 2);
 
INSERT INTO Cars (Name, Price) VALUES ('Audi', 3000)                   #=> если столбец(тут id) создан с параметром AUTOINCREMENT то его значения добавятся автоматически, соотв их писать не нужно
INSERT INTO Cars (Name) VALUES ('Audi')                                #=> если добавить строку, содержащую не все столбцы, то в незаполненных столбцах будет значение NULL
INSERT INTO Cars VALUES ('Mersedes', 5000);                            #=> можно опустить имена столбццов если заполняем все по порядку
INSERT INTO users (name, age) VALUES('Алексей', 38), ('Мартин', 12);   #=> добавление нескольких строк в одном запросе

	datetime() - Фишка sqlite3(??) Когда ставим значением столбца datetime() то в него помещается текущие дата и время(часовой пояс -3)
INSERT INTO Posts (content, created_date) VALUES ('Something', datetime());


	Сложная вставка где одно из значений получается при помощи подзапроса возвращающего необходимое значение
INSERT INTO Goods 
SELECT 
    COUNT(*) + 1, 
    'Table', 
    (SELECT type FROM Goods JOIN GoodTypes ON GoodTypes.good_type_id = Goods.type WHERE GoodTypes.good_type_name = 'equipment' LIMIT 1)
FROM Goods;



				3. UPDATE - редактирования существующих записей в таблицах

UPDATE имя_таблицы SET поле_таблицы1 = значение_поля_таблицы1, поле_таблицыN = значение_поля_таблицыN [WHERE условие_выборки]

(!!! Будьте внимательны, когда обновляете данные. Если вы пропустите оператор WHERE, то будут обновлены все записи в столбце/таблице. !!!)

UPDATE Family SET name = "Andie Anthony" WHERE name = "Andie Quincey";     #=> если в столбце name есть значение "Andie Quincey" то заменим его на "Andie Anthony"
UPDATE users SET name = 'Иван' WHERE id = 5 AND age = 44;                  #=> с 2мя условиями выборки
UPDATE users SET name = 'Иван', password ='qwerty' WHERE id = 5;           #=> меняем значение сразу 2х колонок у строки с айди 5
UPDATE Payments SET unit_price = unit_price * 2                            #=> меняем все значения столбца unit_price на их удвоенные значения
UPDATE Payments SET unit_price = unit_price * 3 WHERE id > 6               #=> меняем те значения столбца unit_price на их утроенные значения, если их айди больше 6




				4. DELETE и TRUNCATE  -  операторы удаления записей из таблицы. Наиболее универсальным и безопасным является DELETE

DELETE FROM имя_таблицы [WHERE условие_отбора_записей];                    
	(Если условие отбора записей WHERE отсутствует, то будут удалены все записи указанной таблицы. Записи удаляются по одной)
	(Оптимизатор запросов СУБД MySQL автоматически использует оператор TRUNCATE, если оператор DELETE не содержит условия WHERE или конструкции LIMIT)

DELETE FROM test WHERE id > 10                     #=> удаляем все строки где значение id больше 2

TRUNCATE TABLE имя_таблицы;
	(выполнит удаление таблицы и пересоздаст её заново - этот вариант работает гораздо быстрее, чем удаление всех записей одна за другой как в случае с DELETE)
	Не срабатывают триггеры, в частности, триггер удаления
	Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
	Сбрасывает счётчик идентификаторов до начального значения
	Чтобы использовать, необходимы права на изменение таблицы


	Удаление записей при многотабличных запросах
	(Если в DELETE запросе используется JOIN, то необходимо указать из каких(ой) именно таблиц(ы) требуется удалять записи)

DELETE имя_таблицы_1 [, имя_таблицы_2] FROM имя_таблицы_1 JOIN имя_таблицы_2 ON имя_таблицы_1.поле = имя_таблицы_2.поле [WHERE условие_отбора_записей];

DELETE Reservations FROM Reservations JOIN Rooms ON Reservations.room_id = Rooms.id WHERE Rooms.has_kitchen = false;	     #=> указываем имя таблицы Reservations(между DELETE и FROM) из которой удаляем                                              
DELETE Reservations, Rooms FROM Reservations JOIN Rooms ON Reservations.room_id = Rooms.id WHERE Rooms.has_kitchen = false;  #=> указываем 2 таблицы если хотим удалить из 2х































