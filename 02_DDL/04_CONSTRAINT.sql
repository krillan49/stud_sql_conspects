--                                    CONSTRAINT. Ограничения для колонок и таблиц

-- CONSTRAINT - свойства/опции/ограничения для колонок/полей или таблиц. Записываются после имени столбца и типа данных или [PostgreSQL] после записи всех столбцов



--                                                 PRIMARY KEY

PRIMARY KEY -- (первичный ключ) значение поля(колонки) с этим ограничением однозначно определяет запись(строку) в таблице. СУБД не позволит нам создать новую запись, где значение в этой колонке будет неуникальным(накладывает ограничение уникальности UNIQUE), этим гарантирует уникальность всей строки. Так же не позволяет всталять в колонку NULL значение, тоесть включает в себя и ограничение NOT NULL. Может быть только 1 первичный ключ во всей таблице, но он может быть наложен на несколько полей одновременно(композитный).

-- [ PostgreSQL ] Единственная разница между PRIMARY KEY и просто колонкой UNIQUE NOT NULL, в том что в просто колонке нет кластеризованных ключей.

-- Сурогатный первычный ключ - это первичный ключ который мы сами назначем, тоесть пользователь не заполняет значение этой колонки для новой записи сам. Реадлизуется, например при помощи SERIAL в PostgreSQL или AUTO_INCREMENT в SQLite и MySQL.
-- Натуральный первичный ключ - это первичный ключ который который записывает сам пользователь, например поле login или email может являться первичным ключем тк их значения обычно задаются уникальными

-- [PostgreSQL] если ограничение пишем в отдельной строке, а не задаем в строке колонки, то:
PRIMARY KEY(login, email) -- можно назначить составной первичный ключ по уникальности комбинации нескольких полей. Таким полям, каждому оттдельно, стоит задать ограничение NOT NULL



--                                       Автоинкремент [ SQLite, MySQL ]

-- Значения в поле с таким ограничением  будет автоматически увеличиваться при добавление новых записей. Максимум одна такая колонка. Можно применять только к INT и FLOAT.

AUTO_INCREMENT -- [ MySQL ]
AUTOINCREMENT  -- [ SQLite ]



--                                                 FOREIGN KEY

FOREIGN KEY (имя_столбца) REFERENCES имя_таблицы_с_первичным_ключем(ее_первичный_ключ) -- синтаксис создания внешнего ключа
-- REFERENCES - значит ссылка

-- [ PostgreSQL ] При создании ключа во время создания таблтцы, если создаем ключ синтаксисом сразу для столбца, а не после всех столбцов - не обязвтельно писать FOREIGN KEY, достаточно REFERENCES
fk_publisher_id INTEGER REFERENCES publisher(publisher_id) NOT NULL
-- fk_publisher_id - имя столбца для которого создаем FOREIGN KEY
-- publisher(publisher_id) - publisher имя таблицы, publisher_id имя поля в таблице на которое мы ссылаемся

-- Внешний/вторичный ключ (необязателен, может быть несколько) - поле с этим свойством ссылается на первичный ключ в другой таблице, позволяет связать 2 таблицы и удобно делать запросы объединяющие данные из них. Позволяет ссылаться(добавлять) только на существующие значения таблицы с PRIMARY KEY к которому он относится. В поле с FOREIGN KEY должны быть те же значения того же типа что и в поле другой таблицы с PRIMARY KEY.

-- Таблица с внешним ключом называется дочерней, а таблица с первичным ключом называется ссылочной или родительской (одна таблица может быть и той и другой одновременно).

-- [ PostgreSQL ??, MySQL + ] Есть разные дополнительные правила для полей с FOREIGN KEY, описывающие как обрабатывать удаление и редактирование при использовании внешних ключей:
ON DELETE RESTRICT -- СУБД не даст удалить компанию, у которой в таблице Users есть данные
ON DELETE CASCADE  -- каскадное удаление, те при удалении компании будут удалены все пользователи, ссылающиеся на эту компанию.
ON DELETE SET NULL -- СУБД запишет NULL в качестве значения поля company для юзеров, работавших в удалённой компании.
ON UPDATE CASCADE  -- если компания изменит свой идентификатор, то все пользователи (Users) получат новый идентификатор в поле company.



--                                     Распостраненные ограничения для колонок

UNIQUE -- значения в данной колонке для всех записей должны быть отличными друг от друга.

-- [PostgreSQL] если ограничение пишем в отдельной строке, а не задаем в строке колонки, то:
UNIQUE(first_name, last_name) -- можем ограничить на уникальность не по 1му полю, а по нескольким сразу, тоесть можно одинаковое имя, если разные фамилии, но нельзя одинаковые и имя и фамилию


NOT NULL -- значения в данной колонке должны быть отличными от NULL, тоесть обязательны к заполнению, если будет не заполнено выдаст ошибку. По умолчанию стоит ограничение NULL, тоесть возможность колонке иметь пустые значения


DEFAULT -- установит значение в колонке по умолчанию, тоесть если при добавлении данных не будет заполнена колонка то добавится значение по умолчанию вместо NULL (данный параметр не применяется к типам BLOB, TEXT, GEOMETRY и JSON).
-- Значение по умолчанию должно быть того же типа данных, что и колонка:
field1 BOOL DEFAULT(FALSE)
field1 TIMESTAMP DEFAULT(NOW())



--                                               CHECK [PostgreSQL]

-- CHECK(expr) - ограничивает значение поля логическим выражением, которое принимет как параметр

CHECK(LENGTH(login) > 6)                   -- длинна значения(строки) для поля login должна быть больше 6
CHECK(LENGTH(login) > 6 AND login <> name) -- составное условие, чтобы логин и имя не совпадали

-- Если ограничение пишем в отдельной строке, а не задаем в строке колонки, то:
CHECK(LENGTH(login) > 6 AND LENGTH(org_name) > 3) -- можем объединять условия CHECK на разные столбцы в одно ограничение

-- Строить валидации в БД плохо почти всегда. Вообще разнос бизнес-логики в разные места это не очень. В БД можно делать валидацию на констрейнах и на обязательности атрибутов. Все, что свыше - семантически относится уже не к хранению, а к бизнес-логике, и должно лежать в приложении. В большой компании может не быть доступа к БД на проде и соответсвенно изменить валидации.



--                                        Имена для ограничений [PostgreSQL]

-- Можно задавать название для ограничения(если не задавать, то имя дается автоматически), чтобы если оно нарушалось, то при вызове исключения писалось это название и мы понимали точно в чем проблема, особенно удобно для кастомных ограничений CHECK.

-- Синтаксис - сначала CONSTRAINT, потом название, потом само ограничение:
CONSTRAINT length_more_then_six CHECK(LENGTH(login) > 6)
CONSTRAINT unique_name UNIQUE(first_name, last_name)
CONSTRAINT pk_publisher_id PRIMARY KEY (publisher_id)    -- создадим имя для первичного ключа(тут pk_publisher_id), по соглашениям задается как имя столбца с префиксом pk_ для праймари кей

-- Посмотреть название ограничения для конкретной колонки из таблицы и схемы:
SELECT constraint_name
FROM information_schema.key_column_usage
WHERE table_name = 'chair' AND table_schema = 'public' AND column_name = 'cathedra_id';


















--
