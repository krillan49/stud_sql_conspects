--                                    CONSTRAINT. Ограничения для колонок и таблиц

-- Основные свойства/опции/ограничения для колонок/полей. Записываются после имени столбца и типа данных:


-- 1. PRIMARY KEY / первичный ключ  – это поле, значение которого однозначно определяет запись в таблице. С помощью данного правила СУБД не позволит нам создать новую запись, где id будет неуникальным. Может быть только 1 первичный ключ во всей таблице, но он может быть наложен на несколько полей одновременно(композитный).

-- Сурогатный первычный ключ - это первичный ключ который мы сами назначем, например при помощи serial(пользователь не заполняет значение сам)
-- Натуральный первичный ключ - это первичный ключ который который записывает сам пользователь, например поле login или email может являться первичным ключем тк они обычно задаются уникальными

PRIMARY KEY    -- указывает колонку или несколько колонок одновременно, как первичный ключ. Он всегда уникальный(накладывает ограничение уникальности UNIQUE), этим гарантирует уникальность всей строки. Так же не позволяет всталять в колонку NULL значение, тоесть включает в себя и ограничение NOT NULL.

-- [ PostgreSQL ] Единственная разница между PRIMARY KEY и просто колонкой UNIQUE NOT NULL, в том что в просто колонке нет кластеризованных ключей.


-- 2. FOREIGN KEY (имя_столбца) REFERENCES имя_таблицы_с_первичным_ключем (id) - создания таблицы с внешним ключом.
-- Внешний или вторичный ключ (необязателен, может быть несколько) - то поле в одной таблице, которое ссылается на первичный ключ в другой таблице, позволяет ссылаться(добавлять) только на существующие значения таблицы с PRIMARY KEY к которому он относится и в поле FOREIGN KEY должны быть те же значения того же типа. Позволяет связать 2 таблицы и удобно делать запросы объединяющие данные из них
-- REFERENCES - значит ссылка.
-- Таблица с внешним ключом называется дочерней, а таблица с первичным ключом называется ссылочной или родительской (одна таблица может быть и той и другой одновременно).

-- [ PostgreSQL ??, MySQL + ] Есть разные правила (?? для полей с FOREIGN KEY) как обрабатывать удаление и редактирование при использовании внешних ключей:
ON DELETE RESTRICT -- база данных не даст удалить компанию, у которой в таблице Users есть данные
ON DELETE CASCADE  -- каскадное удаление, те при удалении компании будут удалены все пользователи, ссылающиеся на эту компанию.
ON DELETE SET NULL -- база данных запишет NULL в качестве значения поля company для юзеров, работавших в удалённой компании.
ON UPDATE CASCADE  -- если компания изменит свой идентификатор, то все пользователи (Users) получат новый идентификатор в поле company.


-- 3. Разные ограничения для колонок:
UNIQUE    -- значения в данной колонке для всех записей должны быть отличными друг от друга.
NOT NULL  -- значения в данной колонке должны быть отличными от NULL, тоесть обязательны к заполнению, если будет не заполнено выдаст ошибку. По умолчанию стоит ограничение NULL, тоесть возможность колонке иметь пустые значения
DEFAULT   -- установит значение в колонке по умолчанию, тоесть если при добавлении данных не будет заполнена колонка то добавится значение по умолчанию вместо NULL (данный параметр не применяется к типам BLOB, TEXT, GEOMETRY и JSON).


-- 4. CHECK(expr) [PostgreSQL] - ограничивает значение поля логическим выражением, которое принимет как параметр
CHECK(LENGTH(login) > 6)                   -- дллинна значения для поля login должна быть больше 6
CHECK(LENGTH(login) > 6 AND login <> name) -- составное условие, чтобы логин и имя не совпадали


-- [PostgreSQL] если ограничение пишем в отдельной строке, а не задаем в строке колонки, то:
PRIMARY KEY(login, email)                         -- можно назначить составной первичный ключ по уникальности комбинации полей. Таким полям отдельно стоит задать NOT NULL
CHECK(LENGTH(login) > 6 AND LENGTH(org_name) > 3) -- можем объединить все условия CHECK на разные столбцы в одно ограничение
UNIQUE(first_name, last_name)                     -- можем ограничить на уникальность не по 1му полю, а по 2нескольким сразу, тоесть можно одинаковое имя, если разные фамилии, но нельзя одинаковые и имя и фамилию


-- CONSTRAINT [PostgreSQL] - можно задавать название для ограничения(При обычном способе создания имя дается автоматически), чтобы если оно нарушалось, то при вызове исключения писалось это название и мы понимали точно в чем проблема, особенно удобно для кастомных ограничений CHECK.
CONSTRAINT length_more_then_six CHECK(LENGTH(login) > 6)   -- nе CONSTRAINT потом название, потом ограничение
CONSTRAINT unique_name UNIQUE(first_name, last_name)
CONSTRAINT pk_publisher_id PRIMARY KEY (publisher_id)

-- Посмотреть название ограничения для конкретной колонки таблицы из схемы
SELECT constraint_name
FROM information_schema.key_column_usage
WHERE table_name = 'chair'
  AND table_schema = 'public'
  AND column_name = 'cathedra_id';


-- [ SQLite, MySQL ]
AUTO_INCREMENT -- значение будет автоматически увеличиваться при добавление новых записей. Максимум одна такая колонка. Можно применять только к int и float.

















-- 
