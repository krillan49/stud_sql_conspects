--                                         Оптимизация запросов

-- !! Потом какото сопоставить с 05o_index !!


-- Таблица film содержит 1000 строк
SELECT * FROM film;

-- EXPLAIN - при помощи этой команды выводится план выполнения запроса без выполнения самого запроса
EXPLAIN
SELECT * FROM film;
-- => Seq Scan on film (cost=0.00..64.00 rows=1000 width=384)
-- Seq Scan          - значит просто чтение всех строк
-- cost=0.00..64.00  - цена, некая мера в которой планировщик запросов считает эффективность всех возможных планов выполнения запроса и выбирает план с наименьшей ценой/стоимостью, тоесть тот что будет выполнен быстрее
-- rows=1000         - число строк в результате запроса
-- width=384         - объем ??использованной?? памяти

-- cost - влияет например скорость чтения с диска, если мы используем HDD(механический жеский диск с вразающимися элементами и головкой), то 1 чтение с диска заниманьт относительно большое время, а если SSD то чтение с диска занимет меньше времени. В настройках PostgreSQL можно выставить стоимость для одного чтения с диска и соответсвенно если у нас HDD то ставим ее побольше, а если SSD то поменьше и планировщик будет учитовать это(стоимость 1й операции чтения) при построении плана запроса.


-- Посмотрим план выполнения для запроса с ограничением выборки при помощи WHERE
-- EXPLAIN ANALYZE - выдаст и план выполнения запроса и выполнит его, а затем выдаст информацию о выполнении запроса
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 120;
-- => Seq Scan on film (cost=0.00..66.50 rows=456 width=384) (actual time=0.020..0.662 rows=457 loops=1)
-- =>   Filter (length > 120)
-- =>   Rows Removed by Filter: 543
-- => Planning Time: 0.148 ms
-- => Execution Time: 0.738 ms
-- actual time=0.020..0.662 - реальное время выполнение шага
-- loops=1 - число проходов по таблице
-- Planning Time  - запланированное время выполнение запроса
-- Execution Time - реальное время выполнения данного запроса, может немного отличаться даже при одном и том же запросе

-- Тоесть выполненный тут план выполнения был пройти всю таблицу и для каждой строки проверить заданное условие, если под него предполагается подходящими мало строк, а всего строк очень много, то это будет не очень эффективно
-- Данную проблему можно решить применением индекса
CREATE INDEX film_length_idx ON film(length);

-- Пример создания индекса по 2м полям, чтобы эффективнее выполнять поиск сразу по 2м полям
CREATE INDEX film_length_idx ON film(length, some);

-- B-tree (Balanced Tree/сбалансированное дерево) - создается по умолчанию, когда мы создаем некоторую колонку с PRIMARY KEY или UNIQUE или просто выполняем команду создания индекса без доп опций.
-- Balanced Tree/сбалансированное дерево - это иерархическая структкра (?бинарное дерево?) и она внутри себя хранит в упорядоченном виде идетификаторы всех записей из таблицы с проиндексированым полем. И упорядочены айдишники как раз по значениям  проиндексированного поля(или полей, если создали индекс по 2м полям). И если нам нужно найти например фильмы с продолжительностью больше какогото значения в проиндексированной колонке, то сначала идем не в таблицу, а в индекс, внутри него находим все айдишники подходящие под наше условие, а ищутся они при помощи дерева очень быстро(?? бинарный поиск??)

-- Выполним тот же запрос но уже с созданным индексом по полю length

-- Запрос который не нашел фильмов, прочекал это по индексу даже не смотря в таблицу, выдаст пустой ответ
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 200;
-- => Index Scan using film_length_idx on film (cost=0.28..8.28 rows=1 width=384) (actual time=0.013..0.014 rows=0 loops=1)
-- =>   Index Cond: (length > 200)
-- =>   Planning Time: 0.421 ms
-- => Execution Time: 0.036 ms
-- Index Scan using film_length_idx on film - тоесть теперь поиск был по индексам
-- Теперь Execution Time/Время выполнения реального запроса сократилось на порядок

-- Запрос который нашел 39 фильмов из 1000 строк
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 180;
-- => Bitmap Heap Scan on film (cost=4.58..57.31 rows=39 width=384) (actual time=0.041..0.080 rows=39 loops=1)
-- =>   Recheck Cond: (length > 180)
-- =>   Heap Blocks: exact=29
-- =>   -> Bitmap Index Scan on film_length_idx (cost=0.00..4.57 rows=39 width=384) (actual time=0.028..0.029 rows=39 loops=1)
-- =>      Index Cond: (length > 180)
-- => Planning Time: 0.134 ms
-- => Execution Time: 0.146 ms
-- Теперь Execution Time/Время выполнения реального запроса сократилось в несколько раз
-- Тут было выбранно сканирование по индексу с помощью битовой карты(bitmap index scan)
-- Мы сначала по индексу нашли айдишники 39 фильмов(bitmap index scan) и хто заняло всего 0.028 милисекунды и далее мы с этими 39 индексами обратились к таблице film (Bitmap Heap Scan on film) и из нее запросили только нужные нам 39 строк а не все и это заняло 0.041..0.080 милисекунды итого общее время выполнения составило 0.146 ms


-- Но этот выйгрыш производительности мы получаем не всегда. Чтение индексов тоже занимает какое-то время и если мы будем запрашивать какое-то большое количество записей, то планировщик может отказаться от использования индексов
-- Так если в нашем примере мы будем искать значения, в результате будет число строк большое относительно всех строк (тут примерно половина) планировщик отказывавется от индексного сканирования и выполняет простой обход таблицы, тк это эффективнее чем выбрать индексы для пол таблицы, а потом выбрать записи по этим индексам для пол таблицы
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 120;
-- => Seq Scan on film (cost=0.00..66.50 rows=456 width=384) (actual time=0.020..0.662 rows=457 loops=1)
-- =>   Filter (length > 120)
-- =>   Rows Removed by Filter: 543
-- => Planning Time: 0.148 ms
-- => Execution Time: 0.738 ms

-- Есть примерно 3 диапазона для выбора типа сканирования:
-- 1. Index Scan        - Если мы запрашиваем очень маленькую долю(какую именно зависит от планировщика и его настроек) строк из таблицы. Получаем айдишники строк из таблицы и затем эти строки запрашиваем. Но если строки находятся на разных страницах БД, то прямой запрос к ним может перескакивать со страницы на страницу и несколько раз заходить на одни и те же страница
-- 2. Bitmap Index Scan - Если мы запрашиваем побольше строк (например 30-50 из 1000). Сделано так что сначала исключаем повторные чтения странцы, но будут доп расходы на поддержание отдельной структуры данных(битовой таблицы)
-- 3. Seq Scan          - Если запрашиваем большое число строк



--                                           План выполнения запроса

EXPLAIN ANALYZE
SELECT
  f.title, p.amount
FROM
  film f
  JOIN inventory i USING(film_id)
  JOIN rental r USING(inventory_id)
  JOIN payment p USING(rental_id);
-- => 1 Hash Join (cost=715.56..1084.68 rows=14596 width=384) (actual time=15.184..35.935 rows=14596 loops=1)
-- => 2  Hash Cond: (i.film_id = f.film_id)
-- => 3  -> Hash Join (cost=639.06..969.70 rows=14596 width=8) (actual time=13.084..28.626 rows=14596 loops=1)
-- => 4     Hash Cond: (r.inventory_id = i.inventory_id)
-- => 5     -> Hash Join (cost=510.99..803.28 rows=14596 width=10) (actual time=9.288..19.272 rows=14596 loops=1)
-- => 6        Hash Cond: (p.rental_id = r.rental_id)
-- => 7        -> Seq Scan on payment p (cost=0.00..253.96 rows=14596 width=10) (actual time=0.014..1.722 rows=14596 loops=1)
-- => 8        -> Hash (cost=310.44..310.44 rows=16044 width=8) (actual time=9.181..9.182 rows=16044 loops=1)
-- => 9           Buckets: 16384 Batches: 1 Memory Usage: 755kB
-- => 10          -> Seq Scan on rental r (cost=0.00..310.44 rows=16044 width=8) (actual time=0.060..4.817 rows=16044 loops=1)
-- => 11    -> Hash (cost=70.81..70.81 rows=4581 width=6) (actual time=3.648..3.651 rows=4581 loops=1)
-- => 12       Buckets: 8192 Batches: 1 Memory Usage: 243kB
-- => 13       -> Seq Scan on inventory i (cost=0.00..70.81 rows=4581 width=6) (actual time=0.043..1.656 rows=4581 loops=1)
-- => 14 -> Hash (cost=64.00..64.00 rows=1000 width=19) (actual time=1.958..1.959 rows=1000 loops=1)
-- => 15    Buckets: 1024 Batches: 1 Memory Usage: 60kB
-- => 16    -> Seq Scan on film f (cost=0.00..64.00 rows=1000 width=19) (actual time=0.048..1.419 rows=1000 loops=1)
-- => 17 Planning Time: 2.204 ms
-- => 18 Execution Time: 37.401 ms

-- Hash Join - означает что соединяются 2 таблицы при помощи алгоритма хэш-таблицы

-- Последними выполняются 2 первые строки 1я выполняет Hash Join для них получает данные из шага на строке 3 и строке 14 и потом 2я строка сообщает о соединении. Далее точно так же по уровням остальные строки (5я и 11я для 3й и 4й). Шаг на строке 7, 10, 13, 16 могут начаться первыми и идти параллельно по выполнению и не от чего не зависят, просто берут данные из таблицы, а шаги которые выше и левее их, от них зависят и получают от них данные и вычисляются позже них последовательно по уровням ввкрх и влево

-- По плану видно что первыми соединяются таблицы rental и payment, не смотря что в запросе написаны последними, затем к результату их соединения присоединяется inventory и последней уже film

-- В плане видим какие типы соединений используются (Hash Join, Merge Join или самый неээфективный Nested to Join) и можем както поправить запрос чтобы тип соединения был эффективнее
-- Так же мы видим последовательность соединения таблиц(сначала стоит объединять таблицы с меньшим числом строк)
-- Видим количество строк и стоимости в результате каждого шага, например на какомто шаге идет резкий рост строк или стоимости и мы можем попробовать этого как-то избежать



--                                            Буферный кэш

-- Буферный кэш - есть в Постгресс, ранее прочитанные страницы кэшируются и потом значения могут ситаться из него. Если места в буферном кзше не осталось, то удаляет оттуда страницу к которой меньше всего обращаемся
-- При повторном выполнении запроса - обращается к буферному кэшу не обращаясь к жескому диску, это ускоряем дальнейшие запросы.

-- Это стои учитывать при оптимизации, например если хотим чтобы в кэш записывался редкий запрос
















--
