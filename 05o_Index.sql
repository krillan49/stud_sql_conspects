--                                    Устройство баз данных в PostgreSQL

-- database cluster - одна и более БД, управляемые из под одной инстанции сервера. Например когда мы устанавливаем PostgreSQL, то получаем кластер со специальными утилитарными БД, например tamplate1, которая используется для того чтобы создавать новые БД, она клонируется и из нее создается новая БД

-- Фаилы данных кластера лежат в директории data(часто называется PGDATA). PGDATA - это переменная окружения, указывающая на папку data, тоесть нужна для обращения к ней

-- Для каждой БД есть своя подпапка PGDATA/base

-- Для каждой таблицы и индекса выделяется отдельный фаил. Фаилы по умолчанию бьются по размеру 1Гб, если превышается, то создается еще 1 фаил, но это можно настроить



--                                       Устройство таблиц в PostgreSQL

-- Таблица(хранящаяся по умолчанию в фаилах по 1ГБ) состоит из массива страниц (каждая страница по умолчанию размером 8Кб)

-- Фаил таблицы называется Heap File (не имеет отношение к структуре данных "куча"), он содержит списки неупорядоченных записей различной длинны, структурирован как набор страниц, каждая из которых имеет множество строк



--                                   Страницы и строки таблицы в PostgreSQL

-- Таблица размером 1Гб состоит из страниц по 8Кб, но это не означает что на странице не может быть больших данных/значений превышающих эти 8кб
-- Хранить значения одной строки на разных страницах запрещено и не поддерживается сервером, потому если в строке какойто страницы есть значение превышающее максимальный размер страницы, то оно обрабатывается при помощи механизма TOAST
-- TOAST - the oversized attribute storage technicue. Каждая таблица имеет ассоциированную с ней TOAST-таблицу, в которой хранятся большие значения, нарезанные кусками по 2Кб, а в столбце исходной таблицы помещается ссылка на место в TOAST-таблице, где хранится само значение

-- Каждая страница содержит: заголовок страницы, строки с их заголовками

-- Страница содержит ссылки на строки (CTID). CTID состоит из пары значений: номера страницы и индекса, используя эту инфу PostgreSQL может быстро обращаться к данным находящимся в тех или иных местах



--                                          FSM и VM фаилы в postgresql

-- Рядом с фаилом таблицы лежит фаил FSM (free space map). Имеет в своем названии суффикс FSM. Он хранит значения округленные до 1/256й от размера страницы, это 32 Байта при размере страницы 8Кб. Он используется для того чтобы сервер понимал куда можно сохранить данные определенных размеров

-- FSM не обновляется при каждом обновлении или удалении строк, тк при удалении и обновлении строки ее старая версия не исчезает сразу из памяти, чтобы поддерживать механизм конкурентного доступа к одним и тем же данным

-- Рядом с фаилом таблицы лежит фаил VM(visibility map), фаил имеет суффикс _VM. Эти фаилы хранят биты - 1 бит на страницу, который, если выставлен в значение 1 показывает, что страница не содержит "дохлых версий строк". Это служит для того чтобы сервер быстрее считывал данные



--                                  VACUUM. Проблема фрагментации данных в PostgreSQL

-- Если вообще не обслуживать БД, то фрагментация данных будет нарастать

-- VACUUM [FULL] - команда для очистки "дохлых" версий строк, тоесть как раз тех, что сразу не удалились из памяти. Эта команда не возвращает память операционной системе, тоесть не удаляет, а просто помечает отрезки памяти, как те которые можно перезаписывать новыми данными.
-- Необходим переодический запуск VACUUM. Активно обновляемые БД рекомендуется проходить VACUUM каждую ночь

VACUUM -- команда для очистки "дохлых" версий строк, обычно ее достаточно. Работает параллельно и не берет эксклюзивную блокировку
VACUUM FULL -- с этой опцией производит полный компактинг таблицы, те проведет сжатие таблицы и полную ее перезапись, это долго по времени и требует столько же памяти как и таблица к которой применили данную команду. Потому производится редко. Берет эксклюзивную блокировку на чтение и запись таблицы. Потому используем только если удалили очень много данных

ANALYZE -- Собирает статистику(например распределения данных) о содержимом таблиц и сохраняет результаты в специальном системном каталоге pgstatistic, в результате планировщик запросов после этого может использовать статистику для того чтобы выполнить запрос наиболее эффективно. Если не задать никаких параметров то команда отработает по всем таблицам в текущей БД, нужно указать параметр чтобы пройтись только по конкретной таблице, можно так же задать и отдельные колонки, соотв статистика будет собрана только с них.

VACUUM ANALYZE -- можно запускать совместно

-- Autovacuum - демон\бэкграунд процесс - работает в фоне и делает все автоматически, его работа базируется на собираемой сервером статистики апдэйтов и удалений. Включается эвристически, включает множество настраиваемых параметров. По умолчанию включен и отключать его не рекомендуется. По умолчанию работает для всех таблиц в БД, но можно задать и отдельно конкретную



--                                 Индексы в PostgreSQL. Оптимизация выборки записей

-- Индекс - структура данных, ускоряющая выборку данных из таблицы за счет дополнительных операций записи и использования дополнительного пространства на диске, используемых для хранения стуктуры данных и поддержания ее в актуальном состоянии

-- Индекс это объект базы данных, который можно создавать и удалять
-- Индекс позволяет искать значения без полного перебора строк и сокращать время поиска

-- Так же индексы называют методами доступа, тк индекс устанавливает соотвествие между ключем являющимся обычно значением индексированного столбца и строками таблицы, в которых этот ключ встречается
-- TID - номер блока фаила и позиции строки внутри блока, они идентифицируют строку

-- Зная ключ или информацию о нем, можно найти требуемую строку, не просмавтривая всю таблицу полностью

-- Оптимизация выборки небольшого числа записей - от того сколько записей фильтрует запрос зависит будет ли использован индекс
-- Небольшое число тут это число относительное количества записей содержащихся в таблице

-- По столбцам с PRIMARY KEY или UNIQUE индекс создается автоматически, по умолчанию будет создаваться b-tree индекс

-- Индексы не бесплатны и требуют определенных затрат на свое поддержание. Операции над проиндексированными данными, например вставка, удаление или обновление строк таблицы - индексы созданные для этой таблицы должны быть перестроены, причем в рамках той же транзакции. Обновление же полей таблицы по которым не создавались индексы не приводят к перестроению индексов



--                                         Методы сканирования данных

-- Какие именно методы сканирования включать решает оптимизатор

-- 1. Индексное сканирование (index scan) - очень эффективный метод сканирования. Если есть большой набор проиндексированных данных и мы осуществляем поиск по индексам и потенциально в результирующий набор попададет малое количество строк, то оптимизатор включит индексный поиск. Например когда мы ищем строку по конкретному уникальному целочисленному значению в проиндексированном столбце и на миллион значений вернется всего одна строка

-- 2. Исключительно индексное сканирование (index only scan) - самый эффективный метод сканирования. Некоторые индесы хранят вместе с идентификаторами строк сами проиндексированные значения и это позволяет просто прочитать индекс, вообще без обращения к таблицам, забирая результат прямо из индекса. Тоесть вместо обращения к таблице необходимо лишь заглянуть в карту видимости(VM), чтобы выяснить актуальность индексных записей, тоесть битик выставлен на 1, значит данные актуальны и можно выполнить искл индесное сканирование. В том числе и для этого нужно переодически использовать VACUUM, тк иначе вместо исключительного будет выполнено менее эффективное обычное индексное сканирование

-- 3. Сканирование по битовой карте (bitmap index scan). Подходит если выбрано не так мало как при индексном сканировании, но и не так много как при последовательном. Работает и при поиске более чем по 1 индексу. При увеличении выборки растет вероятность множественного прочтения одних и тех же страниц (теесть разных строк но на тех же страницах, что читались ранее), тогда планировщик может выбрать этот способ сканирования. Сначала возвращает все TID соответсвующие условию и по ним строится битовая карта версий строк, а затем версии строк читаются из таблицы, при этом каждая страница будет прочитана только 1 раз, тоесть уменьшается чисто прыжков между страницами, а при достаточно больших выборках большое число прыжков может нанести ущерб производительности запроса

-- 4. Последовательное сканирование (sequential scan). Планировщик переключантся на этот тип сканирования при слабой селективности запроса, тоесть запрос должен вернуть большое число строк относительно общего числа строк. Даже если поиск идет по проиндексированному столбцу, то при слабой селективности запроса планировщик может наплевать на индексы и пойдет по этому пути сканирования.

-- Иногда плонировщик понимает что проще отсеять строки не подходящие для возрата и просто вернуть все оставшиеся



--                        Виды индексов в PostgreSQL: B-tree, hash, GiST, GIN, SP-GiST, BRIN

SELECT amname FROM pg_am; -- выведет типы индексов доступные на нашем сервере

-- Как правило это будет следующий список:
-- B-tree (сбалансированное дерево)
-- hash (Хэш-индекс)

-- И специализированные индесы:
-- GiST (обобщенное дерево поиска)
-- GIN (обобщенный обратный)
-- SP-GiST (GiST с двоичным разбиением пространства)
-- BRIN (блочно диапазонный)


-- Все типы индексов имеют собственные ограничения, в том числе и по поддерживаемым операциям, используемым в запросе. Например если в запросе есть оператор > а он не поддерживается заданным типом индекса, то сканирование не будет индексным, а станет обычным последовательным



--                                                  B-tree

-- B-tree (Balanced Tree/сбалансированное дерево) - создается по умолчанию, когда мы создаем некоторую колонку как PRIMARY KEY, задаем ограничение UNIQUE или выполняем команду создания индекса без доп опций:
CREATE INDEX index_name ON table_name(column_name);

-- Сложность поиска (как и в принципе по сбалансированным деревьям) O(logN), увеличение данных влияет на результат поиска, но неочень сильно

-- В большинстве случаев достаточно индекса B-tree и соотв он будет лучим выбором

-- Поддерживает операторы примененные к проиндексированной колонке:
-- <, >, <=, >=, =
-- BETWEEN, IN
-- LIKE 'abc%' (но не '%abc')
-- Индексирует значение NULL (тоесть можно использовать IS NULL и IS NOT NULL)



--                                                  Hash

-- Hash (Хэш-индекс) если мы хотим создать хэш-индекс, то нужно дописать спец синтаксис:
CREATE INDEX index_name ON table_name USING HASH (column_name);

-- Сложность поиска по колонке с этим индексом O(1), тоесть мгновенно и не зависит от колличества данных

-- Поддерживает только оператор = для поиска по проиндексированной колонке. Тоесть по быстродействию может обойти B-tree, если предполагается, что при запросах в большинстве случаев будет использоваться именно =. Но на практике он побеждает B-tree не очень сильно, потому используется не часто.

-- Не отражается в журнале предзаписи WAL (в него записываются все изменения в фаилах до того как они сделаны, позволяет восстановить БД если произошел какойто сбой, уменьшает число записей запросов на диск, тк для подтверждения транзации нужны только записи журнала, а не записи каждого изменения в фаилах в результате транзакции). Значит в результате сбоя придется делать реиндекс, а реиндекс на польшом числе данных, к которым идет большое число запросов это очень не просто сделать



--                                          Специализированные индесы

-- Специализированные индесы - используются очень редко и желательно их применять специалистам с познаниями в мат анализе, статистике, структурах даннгых итд


-- 1. GiST (обобщенное дерево поиска) - применяется для индексации геометрических и текстовых типов данных, например для организации полнотекстового поиска.
-- Занимает меньше места на диске чем GIN, но может быть менее эффективен изза дополнительных проверок
-- Может не сработать на огромном числе строк

-- 2. GIN (обобщенный обратный) - применяется обычно для индесации по колонке с типом массива, набора(рэндж), жсон. пар ключ значения. Так же можно использовать для организации полнотекстового поиска(тут имются ввиду и лай и регулярки ??), с более хитрыми запросами чем просто 'abc%'
-- Может не сработать на огромном числе строк

-- 3. SP-GiST (GiST с двоичным разбиением пространства) - используется для наборов данных, которые подразумевают естественную упорядоченность, но не являются сбалансированными, например телефонные номера, которые упорядочены по коду страны, оператору, но остальная часть номера довыольно рандомна.

-- 4. BRIN (блочно диапазонный) - полезен на огромных наборах данных, которые подразумевают естественную упорядоченность, например почтовые индексы или временные метки



--                                 EXPLAIN, EXPLAIN ANALYZE, планировщик запросов

-- Перед тем как построить индекс нужно понять какой именно это будет индекс, или какие есть проблемы с уже существующими индексами, чтобы перестроить их или запросы. Если у нас есть проблема с производительностью, в принципе нужно понять в чем она

EXPLAIN query; -- команда, аналитический инструмент, выдает вместо результата план исполнения запроса, где будет написано каким образом он выполнялся, виды сканирования по которым он производился. Так же выдаст инфу про то какие касты(догадка планировщика о том как долго будет исполняться некий стэйтмент/утверждение в запросе, по сумме затрат по работе с диском или процессором) предположительно возникают. Сам запрос реально выполняться не будет, так что не стоит волноваться о запросах выполняющихся долго.
-- query - например SELECT-запроса, тоесть просто ставим команду перед необходимым запросом и запускаем.

-- Оценка планировщика не всегда может достаточно точно отражать реальность, а гдето и совсем не точно

EXPLAIN ANALYZE query; -- команда и проводит анализ и прогоняет сам запрос и показывает результат и плана и реального примера для более точной и полной инфы



--                                        ANALYZE, планировщик запросов

ANALYZE [table_name [(column1, column2...)]] -- тоесть можно дополнительно задавть отдельные таблицы и их колонки
-- собирает статистику по данным таблицы, помещает результаты в pg_statistic таблицу
-- планировщик смотрит на статистику при построении плана

-- После запуска ANALYZE запросы могут работать быстрее (? изза кэширования)

-- Стоит запускать как минимум раз в день, чем больше обновлений данных, тем чаще надо запускать
-- Autovacuum (если включен) в том числе запускает и ANALYZE



















--
