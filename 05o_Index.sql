--                                    Устройство баз данных в PostgreSQL

-- database cluster - одна и более БД, управляемые из под одной инстанции сервера. Например когда мы устанавливаем PostgreSQL, то получаем кластер со специальными утилилированными БД, например tamplate1, которая используется для того чтобы создавать новые БД, она клонируется и из нее создается новая БД

-- Фаилы данных кластера лежат в директории data(часто называется PGDATA). PGDATA - это переменная окружения, указывающая на папку data, тоесть нужна для обращения к ней

-- Для каждой БД есть своя подпапка PGDATA/base

-- Для каждой таблицы и индекса выделяется отдельный фаил. Фаилы по умолчанию бьются по размеру 1Гб, если превышается, то создается еще 1 фаил, но это можно настроить



--                                       Устройство таблиц в PostgreSQL

-- Таблица(хранящаяся по умолчанию в фаилах по 1ГБ) состоит из массива страниц (каждая страница по умолчанию размером 8Кб)

-- Фаил таблицы называется Heap File (не имеет отношение к структуре данных "куча"), он содержит списки неупорядоченных записей различной длинны, структурирован как набор страниц, каждая из которых имеет множество строк



--                                   Страницы и строки таблицы в PostgreSQL

-- Таблица размером 1Гб состоит из страниц по 8Кб, но это не означает что на странице не может быть больших данных/значений превышающих эти 8кб
-- Хранить значения одной строки на разных запрещено и не поддерживается сервером, потому если в строке какойто страницы есть значение превышающее максимальный размер страницы, то оно обрабатывается при помощи механизма TOAST
-- TOAST - the oversized attribute storage technicue. Каждая таблица имеет ассоциированную с ней TOAST-таблицу, в которой хранятся большие значения, нарезанные кусками по 2Кб, а в столбце исходной таблицы помещается ссылка на место в TOAST-таблице, где хранится само значение

-- Каждая страница содержит: заголовок страницы, строки с их заголовками

-- Страница содержит ссылки на строки (CTID). CTID состоит из пары значений: номера страницы и индекса, используя эту инфу PostgreSQL может быстро обращаться к данным находящимся в тех или иных местах



--                                          FSM и VM фаилы в postgresql

-- Рядом с фаилом таблицы лежит фаил FSM (free space map). Имеет в своем названии суффикс FSM. Он хранит значения округленные до 1/256й от размера страницы, это 32 Байта при размере страницы 8Кб. Он используется для того чтобы сервер понимал куда можно сохранить данные определенных размеров

-- FSM не обновляется при каждом обновлении или удалении строк, тк при удалении и обновлении строки ее старая версия не исчезает сразу из памяти, чтобы поддерживать механизм конкурентного доступа к одним и тем же данным

-- Рядом с фаилом таблицы лежит фаил VM(visibility map), фаил имеет суффикс _VM. Эти фаилы хранят биты - 1 бит на страницу, который, если выставлен в значение 1 показывает, что страница не содержит "дохлых версий строк". Это служит для того чтобы сервер быстрее считывал данные



--                                  VACUUM. Проблема фрагментации данных в PostgreSQL

-- Если вообще не обслуживать БД, то фрагментация данных будет нарастать

-- VACUUM [FULL] - команда для очистки "дохлых" версий строк, тоесть как раз тех, что сразу не удалились из памяти. Эта команда не возвращает память операционной системе, тоесть не удаляет, а просто помечает отрезки памяти, как те которые можно перезаписывать новыми данными.
-- Необходим переодический запуск VACUUM. Активно обновляемые БД рекомендуется проходить VACUUM каждую ночь

VACUUM -- команда для очистки "дохлых" версий строк, обычно ее достаточно. Работает параллельно и не берет эксклюзивную блокировку
VACUUM FULL -- с этой опцией производит полный компактинг таблицы, те проведет сжатие таблицы и полную ее перезапись, это долго по времени и требует столько же памяти как и таблица к которой применили данную команду. Потому производится редко. Берет эксклюзивную блокировку на чтение и запись таблицы. Потому используем только если удалили очень много данных

ANALYZE -- Собирает статистику(например распределения данных) о содержимом таблиц и сохраняет результаты в специальном системном каталоге pgstatistic, в результате планировщик запросов после этого может использовать статистику для того чтобы выполнить запрос наиболее эффективно. Если не задать никаких параметров то команда отработает по всем таблицам в текущей БД, нужно указать параметр чтобы пройтись только по конкретной таблице, можно так же задать и отдельные колонки, соотв статистика будет собрана только с них.

VACUUM ANALYZE -- можно запускать совместно

-- Autovacuum - демон\бэкграунд процесс - работает в фоне и делает все автоматически, его работа базируется на собираемой сервером статистики апдэйтов и удалений. Включается эвристически, включает множество настраиваемых параметров. По умолчанию включен и отключать его не рекомендуется. По умолчанию работает для всех таблиц в БД, но можно задать и отдельно конкретную



--                                 Индексы в PostgreSQL. Оптимизация выборки записей

-- Индекс - структура данных, ускоряющая выборку данных из таблицы за счет дополнительных операций записи и использования дополнительного пространства на диске, используемых для хранения стуктуры данных и поддержания ее в актуальном состоянии

-- Индекс это объект базы данных, который можно создавать и удалять
-- Индекс позволяет искать значения без полного перебора строк и сокращать время поиска

-- Так же индексы называют методами доступа, тк индекс устанавливает соотвествие между ключем являющимся обычно значением индексированного столбца и строками таблицы, в которых этот ключ встречается
-- TID - номер блока фаила и позиции строки внутри блока, они идентифицируют строку

-- Зная ключ или информацию о нем, можно найти требуемую строку, не просмавтривая всю таблицу полностью

-- Оптимизация выборки небольшого числа записей - от того сколько записей фильтрует запрос зависит будет ли использован индекс
-- Небольшое число тут это число относительное количества записей содержащихся в таблице

-- По столбцам с PRIMARY KEY или UNIQUE индекс создается автоматически, по умолчанию будет создаваться b-tree индекс

-- Индексы не бесплатны и требуют определенных затрат на свое поддержание. Операции над проиндексированными данными, например вставка, удаление или обновление строк таблицы - индексы созданные для этой таблицы должны быть перестроены, причем в рамках той же транзакции. Обновление же полей таблицы по которым не создавались индексы не приводят к перестроению индексов



--                                         Методы сканирования данных

-- Какие именно методы сканирования включать решает оптимизатор

-- 1. Индексное сканирование (index scan) - очень эффективный метод сканирования. Если есть большой набор проиндексированных данных и мы осуществляем поиск по индексам и потенциально в результирующий набор попададет малое количество строк, то оптимизатор включит индексный поиск. Например когда мы ищем строку по конкретному уникальному целочисленному значению в проиндексированном столбце и на миллион значений вернется всего одна строка

-- 2. Исключительно индексное сканирование (index only scan) - самый эффективный метод сканирования. Некоторые индесы хранят вместе с идентификаторами строк сами проиндексированные значения и это позволяет просто прочитать индекс, вообще без образения к таблицам, забирая результат прямо из индекса. Тоесть вместо обращения к таблице необходимо лишь заглянуть в карту видимости(VM), чтобы выяснить актуальность индексных записей, тоесть битик выставлен на 1, значит данные актуальны и можно выполнить искл индесное сканирование. В том числе и для этого нужно переодически использовать VACUUM, тк иначе вместо исключительного будет выполнено менее эффективное обычное индексное сканирование

-- 3. Сканирование по битовой карте (bitmap scan). Подходит если выбрано не так мало как при индексном сканировании, но и не так много как при последовательном. Работает и при поиске более чем по 1 индексу. При увеличении выборки растет вероятность множественного прочтения одних и тех же страниц (теесть разных строк но на тех же страницах, что читались ранее), тогда планировщик может выбрать этот способ сканирования. Сначала возвращает все TID соответсвующие условию и по ним строится битовая карта версий строк, а затем версии строк читаются из таблицы, при этом каждая страница будет прочитана только 1 раз, тоесть уменьшается чисто прыжков между страницами, а при достаточно больших выборках большое число прышков может нанести ущерб производительности запроса

-- 4. Ппоследовательное сканирование (sequential scan). Планировщик переключантся на эт тип сканирования при слабой селективности запроса, тоесть запрос должен вернуть большое число строк относительно общего числа строк. Даже если поиск идет по проиндексированному столбцу, то при слабой селективности запроса планировщик может наплевать на индексы и пойдет по этому пути сканирования.

-- Иногда плонировщик понимает что проще отсеять строки не подходящие для возрата и просто вернуть все оставшиеся



--                        Виды индексов в PostgreSQL: B-tree, hash, GiST, GIN, SP-GiST, BRIN

SELECT amname FROM pg_am; -- выведет типы индексов доступные на нашем сервере
-- Как правило это будет следующий список:
-- B-tree (сбалансированное дерево)
-- hash (Хэш-индекс)
-- И специализированные индесы:
-- GiST (обобщенное дерево поиска)
-- GIN (обобщенный обратный)
-- SP-GiST (GiST с двоичным разбиением пространства)
-- BRIN (блочно диапазонный)



















--
