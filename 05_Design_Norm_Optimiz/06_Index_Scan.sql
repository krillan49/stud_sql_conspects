--                                 Индексы в PostgreSQL. Оптимизация выборки записей

-- https://habr.com/ru/articles/247373/

-- Индекс - структура данных, объект базы данных, который можно создавать и удалять с жеского диска. Он позволяет искать значения без полного перебора строк и ускоряет выборку данных из таблицы за счет дополнительных операций записи и использования дополнительного пространства на диске

-- Индекс применяется для оптимизации выборки небольшого числа записей (относительно общего количества записей, содержащихся в таблице). От того, сколько записей фильтрует запрос зависит будет ли использован индекс

-- По столбцам с PRIMARY KEY или UNIQUE индекс создается автоматически (по умолчанию b-tree индекс)

-- Индексы никак визуально не отображаются в таблице ??

-- Так же индексы называют методами доступа, тк индекс устанавливает соотвествие между ключем, являющимся обычно значением индексированного столбца и строками таблицы, в которых этот ключ встречается
-- TID - номер блока, фаила и позиции строки внутри блока, они идентифицируют строку

-- Зная ключ или информацию о нем, можно найти требуемую строку, не просмавтривая всю таблицу полностью

-- Тк индекс это дополнительный объект, то он накладывает дополнительные расходы - например при вставке/редактировании/удалении новых записей мы не только записываем значения в таблицу, но и для всех существующих для нее индексов добавляем айдишник этой новой строки и все эти индексы перестраиваем(причем в рамках той же транзакции), тк айдишники там отсортированы по значению индексируемого поля, те чем больше индексов в таблице тем больше расходы при вставке/редактировании/удалении новых записей.
-- Обновление же полей таблицы по которым не создавались индексы не приводят к перестроению индексов

-- Не нужно прописывать индексы для каждого из полей, так как это негативно скажется на оптимизации БД



--                                         Методы сканирования данных

-- Какой именно метод сканирования использовать решает оптимизатор

-- 1. Индексное сканирование (index scan) - очень эффективный метод сканирования. Если есть большой набор проиндексированных данных и мы осуществляем поиск по индексам и потенциально в результирующий набор попадет малое количество строк относительно общего числа, то оптимизатор включит индексный поиск. Например когда мы ищем строку по конкретному уникальному целочисленному значению в проиндексированном столбце и на миллион значений вернется всего одна строка

-- 2. Исключительно индексное сканирование (index only scan) - самый эффективный метод сканирования. Некоторые индексы хранят вместе с идентификаторами строк сами проиндексированные значения и это позволяет просто прочитать индекс, вообще без обращения к таблицам. Необходимо лишь заглянуть в карту видимости(VM), чтобы выяснить актуальность индексных записей, тоесть бит выставлен на 1, значит данные актуальны и можно выполнить исключительное индесное сканирование. В том числе и для этого нужно периодически использовать VACUUM, тк иначе вместо исключительного будет выполнено менее эффективное обычное индексное сканирование

-- 3. Сканирование по битовой карте (bitmap index scan). Подходит если выбрано не так мало как при индексном сканировании, но и не так много как при последовательном. Работает и при поиске более чем по 1 индексу. При увеличении выборки растет вероятность множественного прочтения одних и тех же страниц (еще непрочитанных строк, но находящихся на тех страницах, что уже читались ранее), тогда планировщик может выбрать этот способ сканирования. Сначала возвращает все TID соответсвующие условию и по ним строится битовая карта версий строк, а затем версии строк читаются из таблицы, при этом каждая страница будет прочитана только 1 раз, что уменьшит число прыжков между страницами, а при достаточно больших выборках большое число прыжков может нанести сильный ущерб производительности запроса

-- 4. Последовательное сканирование (sequential scan). Планировщик переключантся на этот тип сканирования при слабой селективности запроса, тоесть запрос должен вернуть значительную долю строк относительно общего числа строк. Даже если поиск идет по проиндексированному столбцу, то при слабой селективности запроса планировщик может выбрать этот метод.

-- Иногда планировщик понимает что проще отсеять строки, не подходящие для возрата и просто вернуть все оставшиеся



--                                          Виды индексов в PostgreSQL

SELECT amname FROM pg_am; -- выведет типы индексов доступные на нашем сервере

-- Распространенные индексы:
-- B-tree  - сбалансированное дерево, самый распространенный вид индекса
-- hash    - хэш-индекс

-- Специализированные индесы:
-- GiST    - обобщенное дерево поиска
-- GIN     - обобщенный обратный
-- SP-GiST - GiST с двоичным разбиением пространства
-- BRIN    - блочно диапазонный

-- Все типы индексов имеют собственные ограничения, в том числе и по поддерживаемым операциям, используемым в запросе. Например если в запросе есть оператор > а он не поддерживается заданным типом индекса, то сканирование не будет индексным, а станет обычным последовательным



--                                                  B-tree

-- B-tree (Balanced Tree/сбалансированное дерево) - создается по умолчанию, когда мы создаем некоторую колонку с PRIMARY KEY или UNIQUE или просто выполняем команду создания индекса без доп опций:
CREATE INDEX index_name ON table_name(column_name);
-- В большинстве случаев достаточно индекса B-tree и соответственно он будет лучим выбором

-- Пример создания индекса по 2м полям, чтобы эффективнее выполнять поиск сразу по 2м полям
CREATE INDEX film_length_idx ON film(length, some);

-- Balanced Tree/сбалансированное дерево - это иерархическая структкра (бинарное дерево) и она внутри себя хранит в упорядоченном виде идетификаторы всех записей из таблицы с проиндексированым полем. И упорядочены айдишники как раз по значениям  проиндексированного поля. И если нам нужно найти например фильмы с продолжительностью больше какого-то значения и меньше другого в проиндексированной колонке, то сначала идем не в таблицу, а в индекс, внутри него находим все айдишники подходящие под наше условие, а ищутся они при помощи дерева очень быстро, используя бинарный поиск.

-- Сложность поиска (как и в принципе по сбалансированным деревьям) O(logN) - увеличение данных влияет на результат поиска, но не очень сильно

-- Поддерживает операторы примененные к проиндексированной колонке:
-- <, >, <=, >=, =
-- BETWEEN, IN
-- LIKE 'abc%'     (но не '%abc')
-- IS [NOT] NULL   (Индексирует и значение NULL)



--                                                  Hash

-- Hash (Хэш-индекс) если мы хотим создать хэш-индекс, то нужно дописать спец синтаксис USING HASH:
CREATE INDEX index_name ON table_name USING HASH (column_name);

-- Сложность поиска по колонке с этим индексом O(1) - тоесть мгновенно и не зависит от колличества данных

-- Поддерживает только оператор '=' для поиска по проиндексированной колонке. Тоесть по быстродействию может обойти B-tree, если предполагается, что при запросах в большинстве случаев будет использоваться именно '='. Но на практике он побеждает B-tree не очень сильно, потому используется не часто.

-- Не отражается в журнале предзаписи WAL (в WAL записываются все изменения в фаилах до того как они сделаны, позволяет восстановить БД если произошел какойто сбой, уменьшает число записей запросов на диск, тк для подтверждения транзации нужны только записи журнала, а не записи каждого изменения в фаилах в результате транзакции). Значит в результате сбоя придется делать реиндекс, а реиндекс на большом числе данных, к которым идет большое число запросов это очень не простая задача



--                                          Специализированные индексы

-- Специализированные индесы - используются очень редко и желательно их применять специалистам с познаниями в мат анализе, статистике, структурах даннгых итд

-- 1. GiST (обобщенное дерево поиска) - применяется для индексации геометрических и текстовых типов данных, например для организации полнотекстового поиска.
-- Занимает меньше места на диске чем GIN, но может быть менее эффективен изза дополнительных проверок
-- Может не сработать на огромном числе строк

-- 2. GIN (обобщенный обратный) - применяется обычно для индесации по колонке с типом массива, набора(рэндж), JSON, пар ключ-значение. Так же можно использовать для организации полнотекстового поиска(тут имются ввиду и лайк и регулярки ??), с более хитрыми запросами чем просто 'abc%'
-- Может не сработать на огромном числе строк

-- GiST и GIN - Основаны на модуле pg_trgm, который предоставляет функции и операторы для определения схожести алфавитно-цифровых строк, на основе так называемых триграмм/триграфов(группа 3х последовательных символов взятых из строки) и мы можем измерить схожеть 2х строк подсчитав число триграмм, которые есть в обеих
-- Для этого сперва нужно запустить/подключить расширение модуля pg_trgm
CREATE EXTENSION pg_trgm;
-- Далее можем создать и сам индекс
CREATE INDEX indx_name ON table_name USING GIN (field_name gin_trgm_ops);
-- gin_trgm_ops - хз что это ??

-- 3. SP-GiST (GiST с двоичным разбиением пространства) - используется для наборов данных, которые подразумевают естественную упорядоченность, но не являются сбалансированными, например телефонные номера, которые упорядочены по коду страны, оператору, но остальная часть номера довольно рандомна.

-- 4. BRIN (блочно диапазонный) - полезен на огромных наборах данных, которые подразумевают естественную упорядоченность, например почтовые индексы или временные метки



--                                           Удаление индекса

-- DROP INDEX имя_индекса ON имя_таблицы(имя_колонки);  - удаление индекса столбца
DROP INDEX Someidex ON people;          -- удаляем инлекс Someidex из таблицы people

-- Можно и просто если его имя уникально ??
DROP INDEX index_name;















--
