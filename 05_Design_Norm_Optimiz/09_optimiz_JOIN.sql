--                                       План выполнения запроса c JOIN

EXPLAIN ANALYZE
SELECT
  f.title, p.amount
FROM
  film f
  JOIN inventory i USING(film_id)
  JOIN rental r USING(inventory_id)
  JOIN payment p USING(rental_id);
-- =>
-- 1  5 Hash Join (cost=715.56..1084.68 rows=14596 width=384) (actual time=15.184..35.935 rows=14596 loops=1)
-- 2    Hash Cond: (i.film_id = f.film_id)
-- 3  4  -> Hash Join (cost=639.06..969.70 rows=14596 width=8) (actual time=13.084..28.626 rows=14596 loops=1)
-- 4        Hash Cond: (r.inventory_id = i.inventory_id)
-- 5  3     -> Hash Join (cost=510.99..803.28 rows=14596 width=10) (actual time=9.288..19.272 rows=14596 loops=1)
-- 6           Hash Cond: (p.rental_id = r.rental_id)
-- 7  1        -> Seq Scan on payment p (cost=0.00..253.96 rows=14596 width=10) (actual time=0.014..1.722 rows=14596 loops=1)
-- 8  2        -> Hash (cost=310.44..310.44 rows=16044 width=8) (actual time=9.181..9.182 rows=16044 loops=1)
-- 9              Buckets: 16384 Batches: 1 Memory Usage: 755kB
-- 10 1           -> Seq Scan on rental r (cost=0.00..310.44 rows=16044 width=8) (actual time=0.060..4.817 rows=16044 loops=1)
-- 11 3     -> Hash (cost=70.81..70.81 rows=4581 width=6) (actual time=3.648..3.651 rows=4581 loops=1)
-- 12          Buckets: 8192 Batches: 1 Memory Usage: 243kB
-- 13 1       -> Seq Scan on inventory i (cost=0.00..70.81 rows=4581 width=6) (actual time=0.043..1.656 rows=4581 loops=1)
-- 14 4  -> Hash (cost=64.00..64.00 rows=1000 width=19) (actual time=1.958..1.959 rows=1000 loops=1)
-- 15       Buckets: 1024 Batches: 1 Memory Usage: 60kB
-- 16 1     -> Seq Scan on film f (cost=0.00..64.00 rows=1000 width=19) (actual time=0.048..1.419 rows=1000 loops=1)
-- 17    Planning Time: 2.204 ms
-- 18    Execution Time: 37.401 ms

-- Hash Join - означает что соединяются 2 таблицы при помощи алгоритма хэш-таблицы

-- 1. Шаги на строках 7, 10, 13, 16 могут начаться первыми и идти параллельно по выполнению и не от чего не зависят, просто берут данные из таблиц, от них зависят шаги которые выше и левее их, тк получают от них данные и вычисляются позже них последовательно по уровням вверх и влево
-- 2. Последними выполняются 2 первые строки: 1я выполняет Hash Join для них получает данные из шага на строке 3 и строке 14 и потом 2я строка сообщает о соединении.
-- 3. Точно так же по уровням выполняются остальные строки (5я и 11я для 3й и 14й).

-- По плану видно последовательность соединения таблиц - первыми соединяются таблицы rental и payment, не смотря на то, что в запросе написаны последними, затем к результату их соединения присоединяется inventory и последней уже film
-- Сначала стоит объединять таблицы с меньшим числом строк

-- Видим количество строк и стоимости в результате каждого шага, например на какомто шаге идет резкий рост строк или стоимости и мы можем попробовать этого как-то избежать

-- В плане видим какие типы соединений используются (Hash Join, Merge Join или самый неээфективный Nested Loop Join) и можем как-то поправить запрос чтобы тип соединения был эффективнее



--                       Алгоритмы соединения таблиц: Nested Loop Join, Hash Join и Merge Join

-- В PostgreSQL существует три основных типа алгоритмов соединения: Nested Loop Join, Hash Join и Merge Join. Каждый из них имеет свои преимущества и варианты использования.

-- 1. Nested Loop Join - (вложенное циклическое соединение) это самый простой алгоритм соединения. Он работает путем итерации по каждой строке во внешней таблице и сравнения ее с каждой строкой во внутренней таблице, в соответсвии с условием соединения.
-- Подходит для небольших таблиц или когда одна таблица намного меньше другой.

-- 2. Hash Join - эффективнее, чем Nested Loop Join для больших таблиц. Создает хэш-таблицу для меньшей из таблиц (внутренней таблицы) на основе условия соединения(например поля по которому соединяем). Затем сканирует большую таблицу (внешнюю таблицу) и ищет соответствующие строки в хэш-таблице.
SELECT * FROM orders JOIN customers ON orders.customer_id = customers.id;
-- В этом случае PostgreSQL создаст хэш-таблицу для таблицы "customers" на основе id клиента. Затем просканирует таблицу "orders" и найдет соответствующую информацию о клиенте в хэш-таблице, используя customer_id.

-- 3. Merge Join - (слияния соединений) эффективный алгоритм для объединения двух предварительно отсортированных таблиц. Он работает путем одновременного сканирования обеих таблиц и сравнения строк на основе условия объединения.


-- В PostgreSQL иможно принудительно отключить Nested Loop Join и/или Merge Join, чтобы всегда использовалось Hash Join:
SET enable_nestloop = off;   -- отключить Nested Loop Join при помощи параметра конфигурации 'enable_nestloop'
SET enable_mergejoin = off;  -- отключить Merge Join при помощи параметра конфигурации 'enable_mergejoin'
-- Но это не рекомендуется, тк планировщик запросов в разумно оценивает сложность запроса, доступные ресурсы и статистику, чтобы определить подходящий способ соединения. Вместо того, чтобы вручную применять определенный алгоритм соединения, рассмотрите возможность оптимизации запросов, обеспечения наличия соответствующих индексов














-- 
