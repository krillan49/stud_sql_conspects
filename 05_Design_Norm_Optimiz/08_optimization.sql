--                                          Оптимизация запросов

-- PostgreSQL очень быстрая для чтения СУБД, но очень медленная для вставки по сравнению с тем же MySQL



--                                             Буферный кэш

-- Буферный кэш - есть в Постгресс, ранее прочитанные страницы кэшируются и потом значения могут ситаться из него. При повторном выполнении запроса - обращается к буферному кэшу не обращаясь к жескому диску, это ускоряем дальнейшие запросы.

-- Если места в буферном кзше не осталось, то удаляет оттуда страницу к которой меньше всего обращаемся

-- Это стои учитывать при оптимизации, например если хотим чтобы в кэш записывался редкий запрос



--                                     Оптимизация запросов на примерах

-- Таблица film содержит 1000 строк
SELECT * FROM film;

-- Посмотрим план выполнения запроса без выполнения самого запроса
EXPLAIN
SELECT * FROM film;
-- => Seq Scan on film (cost=0.00..64.00 rows=1000 width=384)
-- Seq Scan          - значит просто чтение всех строк
-- cost=0.00..64.00  - cost/цена
-- rows=1000         - число строк в результате запроса
-- width=384         - объем ??использованной?? памяти

-- cost/цена - это некая мера, в которой планировщик запросов считает эффективность всех возможных планов выполнения запроса и выбирает план с наименьшей ценой/стоимостью, тоесть тот что будет выполнен быстрее. Это догадка планировщика о том как долго будет исполняться некий стэйтмент/утверждение в запросе, по сумме затрат по работе с диском или процессором
-- На цену влияет например скорость чтения с диска и если мы используем HDD(механический жеский диск с вращающимися элементами и головкой) то 1 чтение с диска заниманьт относительно большое время, а если SSD то чтение с диска занимет меньше времени. В настройках PostgreSQL можно выставить стоимость для одного чтения с диска и соответсвенно если у нас HDD то ставим ее побольше, а если SSD то поменьше и планировщик будет учитовать это(стоимость одной операции чтения) при построении плана запроса.


-- Посмотрим план выполнения и результаты конкретного запроса с ограничением выборки при помощи WHERE
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 120;
-- => Seq Scan on film (cost=0.00..66.50 rows=456 width=384) (actual time=0.020..0.662 rows=457 loops=1)
-- =>   Filter (length > 120)
-- =>   Rows Removed by Filter: 543
-- => Planning Time: 0.148 ms
-- => Execution Time: 0.738 ms
-- actual time=0.020..0.662 - реальное время выполнение шага
-- loops=1                  - число проходов по таблице
-- Planning Time            - запланированное время выполнение запроса
-- Execution Time           - реальное время выполнения данного запроса, может немного отличаться даже при одном и том же запросе

-- Тоесть выполненный тут план выполнения был пройти всю таблицу и для каждой строки проверить заданное условие, если под него предполагается подходящими мало строк, а всего строк очень много, то это будет не очень эффективно
-- Данную проблему можно решить применением индекса(по умолчанию это будет  B-tree/сбалансированное дерево)
CREATE INDEX film_length_idx ON film(length);

-- Выполним тот же запрос но уже с созданным индексом по полю length

-- Запрос который не нашел фильмов, проверил это по индексу, даже не смотря в таблицу, выдаст пустой ответ
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 200;
-- => Index Scan using film_length_idx on film (cost=0.28..8.28 rows=1 width=384) (actual time=0.013..0.014 rows=0 loops=1)
-- =>   Index Cond: (length > 200)
-- =>   Planning Time: 0.421 ms
-- => Execution Time: 0.036 ms
-- Index Scan using film_length_idx on film - тоесть теперь поиск был по индексам
-- Теперь Execution Time/Время выполнения реального запроса сократилось на порядок

-- Запрос который нашел 39 фильмов из 1000 строк
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 180;
-- => Bitmap Heap Scan on film (cost=4.58..57.31 rows=39 width=384) (actual time=0.041..0.080 rows=39 loops=1)
-- =>   Recheck Cond: (length > 180)
-- =>   Heap Blocks: exact=29
-- =>   -> Bitmap Index Scan on film_length_idx (cost=0.00..4.57 rows=39 width=384) (actual time=0.028..0.029 rows=39 loops=1)
-- =>      Index Cond: (length > 180)
-- => Planning Time: 0.134 ms
-- => Execution Time: 0.146 ms
-- Теперь Execution Time/Время выполнения реального запроса сократилось в несколько раз
-- Тут было выбранно сканирование по индексу с помощью битовой карты(bitmap index scan)
-- Мы сначала по индексу нашли айдишники 39 фильмов(bitmap index scan) и это заняло всего 0.028 милисекунды и далее мы с этими 39 индексами обратились к таблице film (Bitmap Heap Scan on film) и из нее запросили только нужные нам 39 строк а не все и это заняло 0.041..0.080 милисекунды. Итого общее время выполнения составило 0.146 ms


-- Но этот выйгрыш производительности мы получаем не всегда. Чтение индексов тоже занимает какое-то время и если мы будем запрашивать какое-то большое количество записей, то планировщик может отказаться от использования индексов

-- Так если в нашем примере мы будем искать значения, в результате будет число строк большое относительно всех строк (тут примерно половина) планировщик отказывавется от индексного сканирования и выполняет простой обход таблицы, тк это эффективнее чем выбрать индексы для пол таблицы, а потом выбирать записи по этим индексам для пол таблицы
EXPLAIN ANALYZE
SELECT * FROM film WHERE length > 120;
-- => Seq Scan on film (cost=0.00..66.50 rows=456 width=384) (actual time=0.020..0.662 rows=457 loops=1)
-- =>   Filter (length > 120)
-- =>   Rows Removed by Filter: 543
-- => Planning Time: 0.148 ms
-- => Execution Time: 0.738 ms

-- Есть примерно 3 диапазона для выбора типа сканирования:
-- 1. Index Scan        - Если мы запрашиваем очень маленькую долю строк из таблицы (какую именно зависит от планировщика и его настроек). Получаем айдишники строк из таблицы и затем эти строки запрашиваем. Но если строки находятся на разных страницах БД, то прямой запрос к ним может перескакивать со страницы на страницу и несколько раз заходить на одни и те же страницы
-- 2. Bitmap Index Scan - Если мы запрашиваем побольше строк (например 30-50 из 1000). Сделано так что сначала исключаем повторные чтения странцы, но будут доп расходы на поддержание отдельной структуры данных(битовой таблицы)
-- 3. Seq Scan          - Если запрашиваем большое число строк















--
