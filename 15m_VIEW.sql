--                                         VIEW - Представления в SQL

-- (? Тут по Постгрэ, а так хз есть ли они гдето еще и с каким синтаксисом)

-- View / Представление - это SELECT-запрос, который в виде объекта сохраняется в БД (чтото типа виртуальной таблицы)
-- К представлению, так же как к обычной таблице, можно делать обычный SELECT-запрос и его производительность будет такой же как и у запроса к обычной таблице
-- Несколько View можно соединять между собой при помощи JOIN
-- Можно создавать представления на основе других представлений

-- View - позволяет делать кэширование с помощью материализации, те сохраняем результаты некоторого запроса, который выполняется часто и преодически обновляем этот кэш чтобы отдавать актуальные данные
-- Позволяет сокращать сложные запросы, разбивая их на несколько более простых

-- Позволяет подменить реальную таблицу:
-- Позволяет создавать виртуальные таблицы, соединяющие несколько таблиц и клиент не в курсе как там устроены таблицы, тк может пользоваться представлениями, например ему может быть не нужно самому джойнить итд (инкапсуляция)
-- Позволяет скрыть логику агрегации данных, например при работе через ORM(например актив рекорд)
-- Позволяет скрыть информацию(столбцы) от групп пользователей, можно не создавать политики для ограничения доступа к колонкам, а можно просто создать представление, которое не селектит эти столбцы
-- Позволяет скрыть информацию на уровне строк от групп пользователей, строки отсекаются самим запросом

-- Представления это в принципе дополнительный слой абстрации к которму можно применять отдельные правила для защиты

-- Виды View:
-- 1. Временные
-- 2. Рекурсивные
-- 3. Обновляемые
-- 4. Материализуемые

-- Мы можем модифицировать данные через представление только (WHERE использовать можно):
-- Если есть только одна таблица в секции FROM
-- Если не используются DISTINCT, GROUP BY, HAVING, UNION, INTERSECT, EXEPT, LIMIT
-- Не должно быть оконных функций, например MIN, MAX, SUM, COUNT, AVG



--                                      Создание представления SQL

-- Синтаксис создания представления
CREATE VIEW view_name AS
SELECT select_statement;

-- Создадим представление, объединяющее поставщиков и категории, подходит чтоб удобно отдавать на запросы клиента уже предварительно агрегированные данные
CREATE VIEW products_suppliers_categories AS -- даем осмысленное название
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);

-- Это представление сохранено в БД (в ПГАдмин будет в подразделе нашей схемы) и теперь мы можем делать к нему SELECT-запросы:
SELECT * FROM products_suppliers_categories;                       -- результат как у запроса из представления
SELECT * FROM products_suppliers_categories WHERE unit_price > 20; -- можем дополнительно отфильтровать
SELECT * FROM products_suppliers_categories JOIN some USING(id);   -- можем сджойнить с таблицей или другим представлением

-- Так мы создали не матеарилизованное представление - тоесть при запросе к представлению в блок FROM или JOIN или еще где, вместо названия представления будет подставляться и каждый раз заново исполняться весь запрос

-- CREATE MATERIALIZED VIEW  - создает материализованное представление, будет создана реальная таблица, в которой будет сохранен результат запроса. Используется не очень часто.
CREATE MATERIALIZED VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);
-- результат как у запроса теперь будет из этой созданной таблицы, без выполненения запроса представления каждый раз
SELECT * FROM products_suppliers_categories;
-- Его плюс в быстродействии, но минус в том что при обновлении данных в изначальных таблицах, тут их не будет и придется создавать новое материализованное представление либо делать рефрэш, что по сути почти тоже, тк будет заново выполнен селект-запрос представления:
REFRESH MATERIALIZED VIEW products_suppliers_categories



--                                       Обновляемые представления SQL

-- Синтаксис создания или изменения представления, тоесть если не существует будет создан, а если существует, то ее SELECT-запрос будет заменен на новый
CREATE OR REPLACE VIEW view_name AS SELECT select_statement

-- Синтаксис переименования самого представления
ALTER VIEW old_view_name RENAME TO new_view_name

-- Синтаксис удаления представления (IF EXISTS не обязательно)
DROP VIEW IF EXISTS view_name

-- Возможности View при изменении представлений:
-- можно добавить новые столбцы
-- можно переименовать само представление
-- можно удалять представления

-- Ограничения View при изменении представлений(чтобы обойти эти ограничения придется удалить вью и потом создать заново):
-- нельзя удалить существующие столбцы
-- нельзя поменять имена столбцов
-- нельзя поменять порядок следования столбцов


-- Сделаем представления для тяжелых заказов
CREATE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 50;

-- Обновим/изменим это представление изменив SELECT-запрос, оставив заказы еще тяжелее
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100;


-- При обновлении представления не можем добавить новый столбец как тут:
CREATE OR REPLACE VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description,
discontinued -- добавили новый столбец
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);
-- Этот запрос выдаст ошибку с пояснением что нельзя добавить столбец в представление

-- Переименуем представление, чтобы можно было создать новое как выше, тк название уже освободится
ALTER VIEW products_suppliers_categories RENAME TO psc_old;


-- Вставим данные в представление (добавит их и в соответсвующие таблицы)
INSERT INTO heavy_orders
VALUES (11078, 'VINET', 5, '2019-12-10', '2019-12-15', '2019-12-14', 1, 120, 'Hanari Carnes', 'Rua do Paco', 'Bern', NULL, 3012, 'Switzerland');

-- Нельзя удалить данные из таблицы через представление, если их нет в самом этом представлении, ошибки не будет вызвано, но и ничего не удалится
DELETE FROM heavy_orders WHERE freight < 0.05;   -- тк у нас freight > 100 во вью, то из таблицы не удалятся данные меньше
DELETE FROM heavy_orders WHERE freight < 100.25; -- а данные что есть во вью можем удалить из таблицы, тоесть удалится то что между 100 и 100.25



--                                              Опция CHECK

CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100;

-- Попробуем в это вью вставить строку со значением freight < 100, то такая вставка пройдет, тоесть мы можем всталять данные которые противоречат фильтру запроса в представлении
INSERT INTO heavy_orders
VALUES(11900, 'FOLIG', 1, '2000-01-01', '2000-01-05', '2000-01-04', 1, 80, 'Folies gourmandes', '184, chaussee de Tournai', 'Lille', NULL, 59000, 'FRANCE');

-- Но если мы попытаемся найти эту строку во вьюхе то не найдет
SELECT * FROM heavy_orders WHERE order_id = 11900;
-- А если в таблице то найдет это вставленное значение
SELECT * FROM orders WHERE order_id = 11900;

-- WITH LOCAL CHECK OPTION - ограничение, запрещает вставлять данные несоответсующие фильтру в представлении, будет вызвана ошибка
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100
WITH LOCAL CHECK OPTION;

-- WITH CASCADE CHECK OPTION - тоже, но будет проверяться так же для подлежащих представлений, тоесть представлений на которых основано это представление
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100
WITH CASCADE CHECK OPTION;

















--
