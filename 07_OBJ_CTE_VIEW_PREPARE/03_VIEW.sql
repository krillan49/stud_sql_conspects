--                                         VIEW - Представления в SQL

-- (Тут по PostgreSQL)

-- View / Представление - это SELECT-запрос, который в виде объекта сохраняется в БД (что-то типа виртуальной таблицы)
-- К представлению, так же как к обычной таблице, можно делать обычный SELECT-запрос и его производительность будет такой же как и у запроса к обычной таблице
-- Несколько View можно соединять между собой при помощи JOIN
-- Можно создавать представления на основе других представлений

-- View - позволяет делать кэширование с помощью материализации, те сохраняем результаты некоторого запроса, который выполняется часто и преодически обновляем этот кэш чтобы отдавать актуальные данные
-- Позволяет сокращать сложные запросы, разбивая их на несколько более простых

-- Позволяет подменить реальную таблицу:
-- Позволяет создавать виртуальные таблицы, соединяющие несколько таблиц и клиент не в курсе как там устроены таблицы, тк может пользоваться представлениями, например ему может быть не нужно самому джойнить итд (инкапсуляция)
-- Позволяет скрыть логику агрегации данных, например при работе через ORM(например актив рекорд)
-- Позволяет скрыть информацию(столбцы) от групп пользователей, можно не создавать политики для ограничения доступа к колонкам, а можно просто создать представление, которое не селектит эти столбцы
-- Позволяет скрыть информацию на уровне строк от групп пользователей, строки отсекаются самим запросом

-- Представления это в принципе дополнительный слой абстрации к которму можно применять отдельные правила для защиты

-- Виды View:
-- 1. Временные
-- 2. Материализуемые
-- 3. Рекурсивные



--                                      Создание временного представления

-- Не матеарилизованное / временое представление - при запросе к представлению, вместо результата представления будет подставляться и каждый раз заново исполняться запрос из представления, как обычный подзапрос

-- Синтаксис создания временного представления:
CREATE VIEW view_name AS
SELECT какой_то_запрос_результат_которого_станет_виртуальной_таблицей;


-- Создадим представление, объединяющее поставщиков и категории, подходит чтобы удобно отдавать на запросы клиента уже предварительно агрегированные данные
CREATE VIEW products_suppliers_categories AS -- даем осмысленное название
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);

-- Это представление сохранено в БД (в Клиентах будет в подразделе нашей схемы) и теперь мы можем делать к нему SELECT-запросы:
SELECT * FROM products_suppliers_categories;                       -- результат как у запроса из представления
SELECT * FROM products_suppliers_categories WHERE unit_price > 20; -- можем дополнительно отфильтровать
SELECT * FROM products_suppliers_categories JOIN some USING(id);   -- можем сджойнить с таблицей или другим представлением



--                                   Создание материализованного представления

-- CREATE MATERIALIZED VIEW  - создает материализованное представление, будет создана реальная таблица, в которой будет сохранен результат запроса. Используется не очень часто.

CREATE MATERIALIZED VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);
-- В результате испольнения этого скрипта на основе результата этого запроса будет созданна таблица

SELECT * FROM products_suppliers_categories; -- теперь без выполненения запроса представления, просто обращаемся как к таблице

-- Плюс в быстродействии, но минус в том, что при обновлении данных в изначальных таблицах, в таблицу представления они автоматически не добавятся и придется создавать новое материализованное представление либо делать рефрэш, что по сути почти тоже, тк будет заново выполнен селект-запрос представления:
REFRESH MATERIALIZED VIEW products_suppliers_categories;



--                                        Обновление представления

-- Синтаксис создания или обновления представления - если не существует будет создано, а если существует, то его SELECT-запрос будет заменен на новый
CREATE OR REPLACE VIEW view_name AS
SELECT select_statement;


-- Сделаем представления для тяжелых заказов
CREATE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 50;
-- Обновим/изменим это представление изменив SELECT-запрос, оставив заказы еще тяжелее
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100;


-- При обновлении представления не можем добавить новый столбец как тут:
CREATE OR REPLACE VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description,
discontinued -- добавили новый столбец, тут discontinued
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);
-- Этот запрос выдаст ошибку с пояснением что нельзя добавить столбец в представление
-- В виде решения мжно переименовать представление, чтобы можно было создать новое, тк название уже освободится



--                                           Изменение представлений

-- Возможности View при изменении представлений:
-- можно добавить новые столбцы
-- можно переименовать само представление:

-- Ограничения View при изменении представлений(чтобы обойти эти ограничения придется удалить View и потом создать заново):
-- нельзя удалить существующие столбцы
-- нельзя поменять имена столбцов
-- нельзя поменять порядок следования столбцов

-- Синтаксис переименования самого представления
ALTER VIEW old_view_name RENAME TO new_view_name;



--                                           Удаление представлений

-- Синтаксис удаления представления (IF EXISTS не обязательно)
DROP VIEW IF EXISTS view_name;



--                                   Вставка и удаление данных в/через представления

-- Можно модифицировать данные через представление только если (WHERE использовать можно):
-- Если есть только одна таблица в секции FROM
-- Если не используются DISTINCT, GROUP BY, HAVING, UNION, INTERSECT, EXEPT, LIMIT
-- Не должно быть оконных функций, например MIN, MAX, SUM, COUNT, AVG

-- Вставим данные в представление (добавит их и в соответсвующие таблицы)
INSERT INTO heavy_orders
VALUES (11078, 'VINET', 5, '2019-12-10', '2019-12-15', '2019-12-14', 1, 120, 'Hanari Carnes', 'Rua do Paco', 'Bern', NULL, 3012, 'Switzerland');

-- Нельзя удалить данные из таблицы через представление, если их нет в самом этом представлении, ошибки не будет вызвано, но и ничего не удалится
DELETE FROM heavy_orders WHERE freight < 0.05;   -- тк у нас freight > 100 во вью, то из таблицы не удалятся данные меньше
DELETE FROM heavy_orders WHERE freight < 100.25; -- а данные что есть во вью можем удалить из таблицы, тоесть удалится то что между 100 и 100.25



--                                              Опция CHECK

CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100;

-- Попробуем в это вью вставить строку со значением freight < 100, то такая вставка пройдет, тоесть мы можем всталять данные которые противоречат фильтру запроса в представлении
INSERT INTO heavy_orders
VALUES(11900, 'FOLIG', 1, '2000-01-01', '2000-01-05', '2000-01-04', 1, 80, 'Folies gourmandes', '184, chaussee de Tournai', 'Lille', NULL, 59000, 'FRANCE');

-- Но если мы попытаемся найти эту строку во вьюхе то не найдет
SELECT * FROM heavy_orders WHERE order_id = 11900;
-- А если в таблице то найдет это вставленное значение
SELECT * FROM orders WHERE order_id = 11900;


-- WITH LOCAL CHECK OPTION - ограничение, запрещает вставлять данные несоответсующие фильтру в представлении, будет вызвана ошибка
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100
WITH LOCAL CHECK OPTION;

-- WITH CASCADE CHECK OPTION - тоже, но будет проверяться так же для подлежащих представлений, тоесть представлений на которых основано это представление
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100
WITH CASCADE CHECK OPTION;

















--
