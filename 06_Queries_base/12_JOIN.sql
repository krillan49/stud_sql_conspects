--                                         Многотабличные запрсы. JOIN

-- JOIN - оператор многотабличного запроса, позволяет делать выборку из нескольких таблиц, соединяя данные(строки) из них в одном запросе. Тоесть позволяют нам «соединять» строки нескольких таблиц вместе по соответсвующим значениям столбцов в них, используя например внешний ключ одной таблицы и первичный другой

-- Когда происходит отправка запроса, то соединение таблиц происходит в самую первую очередь. В результате соединения будет сформирована результирующая виртуальная таблица и далее уже из этой результирующей таблицы будут браться все данные для остальных действий запроса, например фильтрация даже если она по полям только из 1й таблицы.

-- Соединение бывает:
-- INNER - внутреннее соединение (по умолчанию)
-- OUTER - внешнее соединение. Оно делится на левое LEFT, правое RIGHT и полное FULL
-- СROSS - как декартово произведение(операция над множествами)
-- SELF  - соединение(рекурсивное) таблицы с самой собой

-- ON - оператор после кторого пишется условие о том как именно записи из разных таблиц должны находить друг друга(как они соответствуют друг другу). При использовании ON те поля по которым мы соединяли, по умолчанию выводятся из каждаой таблицы



--                                        Вызов столбцов от конкретных таблиц

-- имя_таблицы.имя_столбца - позволяет при работе с несколькими таблицами выбирать столбцы из определенных таблиц, удобно при одинаковых названиях в разных таблицах
SELECT Customers.Id FROM Customers WHERE Customers.id < 5;
SELECT prod.* AS name FROM prod;

-- Удобно использовать и с псевдонимами таблиц
SELECT c.Id FROM Customers AS c WHERE c.id < 5;



--                                         INNER JOIN (внутреннее соединение)

-- INNER в запросе писать не обязательно тк это значение по умолчанию

-- Внутреннее соединение - находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем самым образуя записи новой таблицы, содержащую поля из первой и второй исходных таблиц. Например если в нашем условии указано равенство значений в полях A.good_id и B.id, то при внутреннем соединении в итоговой выборке окажутся только те записи, где эти значения равны

-- Пошагово (проверяем все строки попарно):
-- 1. берется первая строка из первой таблицы и первая строка из второй, проверяется условие соответсвия для них. Если условие выполняется, то в результирующую таблицу(виртуальную) добавляется новая строка, содержащая все значения 2х соединенных строк. Если условие не выполняется, то в результирующую таблицу эта пара строк не попадает.
-- 2. Далее берем 1ю строку 1й таблицы и 2ю строку второй таблицы и делаем все так же. Дадее 1ю 1й таблици и 3ю второй итд. В итоге проверим 1ю строку первой таблицы со всеми строками второй.
-- 3. Далее берем уже 2ю строку 1й таблицы и проверяем со всем строками 2й таблицы

-- Если соединяется больше 2х таблиц:
-- 1. Соединяем 1ю и вторую таблицы получаем результирующий набор строк(новая виртуальная таблица)
-- 2. Соединяем полученный результирующий набор с 3й таблицей, получаем новый результирующий наобор
-- 3. Проделываем тоже с остальными таблицами

SELECT prod.*, comp.name AS name
FROM prod JOIN comp ON prod.comp_id = comp.id;  -- соединяем из 1й таблицы все, а из 2й одну колонку

-- INNER JOIN + псевдонимы + WHERE(осуществляется после объединения)
SELECT * FROM Customers C JOIN Orders O ON O.CustId = C.Id WHERE O.Total > 200;

-- Если используем * для вывода в запрсе от соединения нескольких таблиц то выведет все поля всех объединенных таблиц:
SELECT * FROM Cus INNER JOIN Ord ON Ord.Nid = Cus.id;  -- соединяем те строки таблиц Cus и Ord в которых Ord.Nid = Cus.id

-- Можно не писать имена таблиц для тех имен колонок в запросе, которых не существует в других объединяемых таблицах
SELECT member, name FROM Pay JOIN Family ON Pay.id = Family.m_id; -- member из таблицы Pay, а name из таблицы Family

-- Соединение 3х таблиц
SELECT Class.name, S_in_c.student, Student.name
FROM Class
JOIN S_in_c ON Class.id = S_in_c.class
JOIN Student ON S_in_c.student = Student.id;

-- INNER JOIN + GROUP BY. Группировка осуществляется после объединения
SELECT people.*, COUNT(*) FROM toys JOIN people ON people.id = toys.people_id GROUP BY people.id;
SELECT Res.room_id, AVG(Rev.rating) AS score FROM Res JOIN Rev ON Res.id = Rev.res_id GROUP BY Res.room_id; -- выбираем Res.room_id и средние значения Rev.rating для каждого Res.room_id при помощи группировки по Res.room_id из объединенных таблиц Res и Rev



--                                       Объединение не по равенству значений

-- Помимо равенства значений можем объединять и по другим отношениям, напроимер != или < или >

-- Объединение по нервыенству значений в колонке, тоесть соединяются значения тех строк таблиц, значения выбранной колонке в которых не равны
SELECT s1.state AS s_a, s2.state AS s_b, s1.total - s2.total AS dif FROM s1 JOIN s2 ON s1.state != s2.state;

-- Объединение по <, тоесть соединяются значения тех строк таблиц, значения выбранной колонке одной тавлицы меньше чем в другой
SELECT s1.state AS s_a, s2.state AS s_b, s2.total - s1.total AS dif FROM s1 JOIN s2 ON s1.state < s2.state;



--                                        Несколько условий соединения

-- В условии соединения могут использоваться несколько соответсвий и логические операторы: AND, OR, NOT.

-- Запись в rank идентифицируется составным суррогатным ключом (store_id, rank_id). Т.е. чтобы найти информацию о должности сотрудника, нужно из таблицы rank взять строку с таким же идентификатором магазина и идентификатором должности в магазине.
SELECT e.first_name, e.last_name, r.rank_id, r.store_id, r.name
FROM e JOIN rank r ON r.rank_id = e.rank_id AND r.store_id = e.store_id AND r.count > 5;

-- Доп условия вроде AND r.count > 5 удобны для внешних соединений, чтобы неподходящие строки оставались со значением NULL а не фильтровались как при обычном условии в WHERE. И можно например сделать COUNT(*) и COUNT(some) в зпросе, что вывести и общее число и число соответсвующих значений, тоесть не являющихся NULL



--                                                    USING

-- USING вместо ON и сравнения - используется для любых видов соединений, если столбец, по равенству значений которого объединяем, в обеих таблицах называется одинаково
-- При использовании USING, те поля по которым мы соединяли, по умолчанию выводятся только 1 раз

SELECT film_id, title, popularity
FROM film
JOIN film_category USING(film_id)
JOIN inventory USING(film_id)
JOIN category ON film_category.category_id = category.category_id AND name = 'Children';
-- AND name = 'Children'  - дополнительная выборка в присоединяемой таблице, удобно для многотабличных джойнов

-- C несколькими полями в USING
SELECT COALESCE(ts.product_id, tr.product_id) AS product_id, sale_qty, return_qty, COALESCE(ts.date, tr.date) AS date
FROM ts FULL JOIN tr USING(product_id, date);



--                                                 NATURAL JOIN

--  Работает как INNER JOIN, а соединение происходит автоматически по всем столбцам что имеют одинаковые имена, тоесть еще короче чем с USING.
-- Не рекомендуется тк код не очень читабелен, не видно столбец по которому соединяем, так же может быть непрактичным, если введут еще столбцы с одинаковыми именами позже
SELECT order_id, customer_id, name, title FROM orders NATURAL JOIN employees;



--                                      OUTER JOIN (внешнее соединение)

-- OUTER JOIN - Внешнее соединение, оно может быть трёх типов: левое LEFT, правое RIGHT и полное FULL. По умолчанию оно является полным. Оно обязательно возвращает все строки одной из таблиц (LEFT, RIGHT) или двух таблиц (FULL)


-- LEFT OUTER JOIN (внешнее левое соединение) - возвращает все значения из левой таблицы, соединённые с соответствующими значениями из правой таблицы, там где они удовлетворяют условию соединения, а там где не удовлетворяют, будут значения из левой таблицы соединенные с значениями NULL. Тоесть все строки левой таблицы гарантировано попадут в результирующий набор.

-- Пошагово: происходит как внутреннее соединение по заданному условию, только если условие не прошло, то строка из 1й таблицы все равно попадает в результирующий набор, а во всех ячейках второй соединяемой таблице значением ставится NULL

SELECT Tim.id, start, Sched.id, class FROM Tim LEFT JOIN Sched ON Sched.num = Tim.id;  -- В выборку попали все строки из левой таблицы Tim, дополненные данными из правой Sched там где Sched.num = Tim.id, а где нет этого соответсвия к данным левой таблицы в колонки соответсвующие правой таблице подставлены NULL

-- Получение данных, относящихся только к левой таблице, которые не соотвествуют ни одной строк из правой таблице по условию соединения, те быудут дополнены значениями NULL:
SELECT * FROM left_tab LEFT JOIN right_tab USING(key) WHERE right_tab.key IS NULL


-- RIGHT OUTER JOIN (внешнее правое соединение): тоже что и левое только все значения возвращаются из правой, а из левой только соотв условию либо NULL.


-- FULL OUTER JOIN (внешнее полное соединение). Реализовано не во всех СУБД.(Есть: PostgreSQL; Нет: MySQL)
-- 1. Формируется таблица на основе внутреннего соединения (INNER JOIN)
-- 2. В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN)
-- 3. В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN)
SELECT employee_name, department_name FROM employees e FULL OUTER JOIN departments d ON d.department_id = e.department_id;

-- Получение данных, не относящихся к левой и правой таблицам одновременно (обратное INNER JOIN):
SELECT поля_таблиц FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
WHERE левая_таблица.ключ IS NULL OR правая_таблица.ключ IS NULL;



--                                      SELF JOIN (Рекурсивное соединение)

-- SELF JOIN - используется тогода, когда нужно построить иерархию в запросе и соединить данные таблицы с другими данными той же самой таблицы.
-- Не имеет своих ключевых слов и используется при помощи ситаксиса остальных соединений (INNER JOIN, OUTER JOIN)

-- Например если у таблицы внешний ключ ссылается на первичный ключ в этой же таблице(но это не обязательно должны быть ключи), то предполагается использование SELF JOIN.

-- У каждого работника может быть менеджер, но сам менеджер тоже работник и соотв тоже может иметь менеджера, тоесть в таблице employee_id сотрудника может ссыласться на manager_id другого сотрудника
SELECT e.name AS employee, m.name AS manager
FROM employee e LEFT JOIN employee m ON m.employee_id = e.manager_id;

-- Объединение с одной и тойже таблицей 2 раза, для того чтоб объединить ее по разным полям
SELECT u.unit_name || COALESCE('/' || u2.unit_name, '') AS dose_units FROM dose_records r
NATURAL JOIN drugs d
JOIN units u ON r.drug_unit_id = u.unit_id
LEFT JOIN units u2 ON r.check_unit_id = u2.unit_id


-- Попарное сравнение (тут ищем все возможные пары актеров, что снимались вместе в одном и том же фильме) для соединительной талицы типа многие ко многим:
-----------------------
-- actor_id	 |  film_id
-----------------------
-- 1	       |  1
-- 1	       |  23
-- 1	       |  25
-- ...       |  ...
-- 2	       |  3
-- 2	       |  31
-- 2	       |  47
-- ...       |  ...
----------------------
-- Соединим эту таблицу саму с собой и в дополнительном условии укажем не просто неравенств id актеров, а один меньше другого, чтобы исключить все повторы и соотв улучшить производительность запроса
SELECT f1.actor_id AS a1_id, f2.actor_id AS a2_id, f1.film_id
FROM film_actor f1 JOIN film_actor f2 ON f1.film_id = f2.film_id AND f1.actor_id < f2.actor_id



--                                      CROSS JOIN (Декартово соединение)

-- 1. СROSS - как декартово произведение(операция над множествами). С каждой записью левой таблицы объединяем каждую запись правой таблицы. Условия соединения не нужны, тк каждая строка одной таблицы объединяется с каждой из другой. Можно комбинировать с другими типами соединения
SELECT product_name, suppliers.company_name, units_in_stock FROM products CROSS JOIN suppliers;

-- При объединении 3х и более таблиц, каждая строка результирующего набора комбинируется с каждой строчкой следующей таблицы


-- 2. Альтернативный способ декадтового соединения - через INNER JOIN, но в качестве условия выбранное такое, которое всегда истинно
SELECT product_name, suppliers.company_name, units_in_stock FROM products JOIN suppliers ON 1 = 1;


-- 3. Альтернативный способ декадтового соединения - если мы не пишем тип соединения, а просто перечисляем все таблицы через запятую
SELECT product_name, suppliers.company_name, units_in_stock FROM products, suppliers;
-- При этои синтаксисе, если мы даже захотим соединить еще таблицы при помощи JOIN, то ссылаться сможем только на поледнюю таблицу до запятой из тех что соединяли декартово этим синтаксисом

-- Альтернатива INNER JOIN ON с перечислением таблиц через запятую и WHERE вместо ON. ? Похоже не очень эффективно, тк фильтр будет применяться к огромной таблице ?
SELECT people.*, toys.toy_count FROM people, toys WHERE people.id = toys.people_id;

-- объединение не по равенству значений
SELECT s1.state AS s_a, s2.state AS s_b, s1.total - s2.total AS dif FROM s1, s2
WHERE s1.state != s2.state AND s1.total - s2.total < 1000;



--                                        JOIN LATERAL. LATERAL Подзапросы

-- (?? Не очень понятно)

-- https://www.postgresql.org/docs/current/queries-table-expressions.html

-- JOIN LATERAL - позволяют джойнить подзапросы ссылающиеся на поля других таблиц, тоесть коррелированные

-- LATERAL Подзапросы - подзапросы в поле FROM могут предваряться ключевым словом LATERAL. Это позволяет им ссылаться на столбцы, предоставленные предыдущими FROM элементами. (Без LATERAL, каждый подзапрос оценивается независимо и поэтому не может ссылаться на какой-либо другой FROM элемент)

-- Табличные функции, появляющиеся в FROM также могут предваряться ключевым словом LATERAL, но для функций ключевое слово является необязательным; аргументы функции могут содержать ссылки на столбцы, предоставленные предыдущими FROM элементами в любом случае.

-- Элемент LATERAL может отображаться на верхнем уровне списка FROM или внутри JOIN дерева. В последнем случае он также может ссылаться на любые элементы, которые находятся слева от того JOIN справа от которого он находится.

-- CROSS JOIN LATERAL:
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
-- Результат точно такой же, как и у традиционного метода:
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;

-- LATERAL полезно, когда перекрестно-ссылаемый столбец необходим для вычисления строк, которые должны быть объединены. Распространенное применение — предоставление значения аргумента для функции, возвращающей множество. Например, предположив, что vertices(polygon) возвращает множество вершин многоугольника, мы могли бы идентифицировать близко расположенные вершины многоугольников, хранящихся в таблице, с помощью:
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2, LATERAL vertices(p1.poly) v1, LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
-- Этот запрос также можно написать
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1, polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
-- LATERAL ключевое слово в этом примере необязательно

-- Часто бывает особенно удобно использовать LEFT JOIN подзапрос LATERAL, чтобы исходные строки отображались в результате, даже если LATERAL подзапрос не выдает для них строк. Например, если get_product_names() возвращает названия продуктов, производимых производителем, но некоторые производители в нашей таблице в настоящее время не производят никаких продуктов, мы могли бы выяснить, какие именно это:
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;












--
