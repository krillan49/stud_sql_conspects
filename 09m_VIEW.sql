--                                         VIEW - Представления в SQL

-- (? Тут по Постгрэ, а так хз есть ли они гдето еще и с каким синтаксисом)

-- View / Представление - это сохраненный запрос в виде объекта хранящегося в БД (чтото типа виртуальной таблицы)
-- К View, после того как мы сделаем запрос и сохраним его в предсталении, можно делать обычный SELECT-запрос и его производительность будет такой же как и у запроса к обычной таблице
-- View можно соединять между собой при помощи JOIN
-- Можно создавать представления на основе других представлений

-- View - позволяет делать кэширование с помощью материализации, те сохраняем результаты некоторого запроса, который выполняется часто и преодически обновляем этот кэш чтобы отдавать актуальные данные
-- Позволяет сокращать сложные запросы, разбивая их на несколько более простых

-- Позволяет подменить реальную таблицу:
-- Позволяет создавать виртуальные таблицы, соединяющие несколько таблиц - инкапсуляция, клиент не в курсе как там устроены таблицы, тк может пользоваться представлениями, например ему может быть не нужно самому джойнить итд
-- Позволяет скрыть логику агрегации данных, например при работе через ORM(например актив рекорд)
-- Позволяет скрыть информацию(столбцы) от групп пользователей, можно не создавать политики для ограничения доступа к колонкам, а можно просто создать представление, которое не селектит эти столбцы
-- Позволяет скрыть информацию на уровне строк от групп пользователей, строки отсекаются самим запросов
-- Представления это в принципе дополнительный слой абстрации к которму можно применять отдельные правила для защиты

-- Виды View:
-- 1. Временные
-- 2. Рекурсивные
-- 3. Обновляемые
-- 4. Материализуемые

-- Синтаксис создания представления
CREATE VIEW view_name AS
SELECT select_statement

-- Ограничения View при изменении представлений(чтобы обойти эти ограничения придется удалить вью и потом созать заново):
-- Можно только добавить новые столбцы
-- можно переименовывать само представление
-- можно удалять представления
-- нельзя удалить существующие столбцы
-- нельзя поменять имена столбцов
-- нельзя поменять порядок следования столбцов

-- Синтаксис создания или изменения представления, тоесть если не существует будет создана, а если существует, то ее содержание будет заменено на новый SELECT-запрос
CREATE OR REPLACE VIEW view_name AS
SELECT select_statement

-- Синтаксис переименования самого представления
ALTER VIEW old_view_name RENAME TO new_view_name

-- Синтаксис удаления представления
DROP VIEW IF EXISTS view_name  -- IF EXISTS не обязательно


-- Мы можем модифицировать данные через представление только (WHERE использовать можно):
-- Если есть только одна таблица в секции FROM
-- Если не используются DISTINCT, GROUP BY, HAVING, UNION, INTERSECT, EXEPT, LIMIT
-- Не должно быть оконных функций, например MIN, MAX, SUM, COUNT, AVG



--                                      Создание представления SQL

-- Создадим представление, объединяющее поставщиков и категории, подходит чтоб удобно отдавать на запросы клиента уже предварительно агрегированные данные
CREATE VIEW products_suppliers_categories AS -- даем осмысленное название
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);

-- Это представление сохранено в БД (в ПГАдмин будет в подразделе нашей схемы) и теперь мы можем делать к нему SELECT-запросы:
SELECT * FROM products_suppliers_categories; -- результат как у запроса из представления
SELECT * FROM products_suppliers_categories WHERE unit_price > 20; -- можем дополнительно отфильтровать



--                                       Обновляемые представления SQL

-- Сделаем представления для тяжелых заказов
CREATE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 50;

-- Обновим/изменим это представление изменив SELECT-запрос, оставив заказы еще тяжелее
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100;

-- При обновлении представления не можем добавить новый столбец как тут:
CREATE OR REPLACE VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, company_name, contact_name, phone, category_name, description,
discontinued -- добавили новый столбец
FROM products JOIN suppliers USING (supplier_id) JOIN categories USING (category_id);
-- Этот запрос выдаст ошибку с пояснением что нельзя добавить столбец в представление

-- Переименуем представление, чтобы можно было создать новое как выше, тк название уже освободится
ALTER VIEW products_suppliers_categories RENAME TO psc_old;

-- Вставим данные в представление (добавит их в соотв таблицы)
INSERT INTO heavy_orders
VALUES (11078, 'VINET', 5, '2019-12-10', '2019-12-15', '2019-12-14', 1, 120, 'Hanari Carnes', 'Rua do Paco', 'Bern', NULL, 3012, 'Switzerland');


-- мы не можем удалить данные из таблицы через представление, которых нет в самом этом представлении, ошибки не будет вызвано, но и ничего не удалится
DELETE FROM heavy_orders WHERE freight < 0.05; -- тк у нас freight > 100 во вью, то из таблицы не удалятся данные меньше
DELETE FROM heavy_orders WHERE freight < 100.25; -- а данные что есть во вью можем удалить из таблицы, тоесть удалится то что между 100 и 100.25



--                                         Опция CHECK в представлениях

CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100;

-- Попробуем в это вью вставить строку со значением freight < 100, то такая вставка пройдет, тоесть мы можем всталять данные которые противоречат фильтру запроса в представлении
INSERT INTO heavy_orders
VALUES(11900, 'FOLIG', 1, '2000-01-01', '2000-01-05', '2000-01-04', 1, 80, 'Folies gourmandes', '184, chaussee de Tournai', 'Lille', NULL, 59000, 'FRANCE');

-- Но если мы попытаемся найти эту строку во вьюхе то не найдет
SELECT * FROM heavy_orders WHERE order_id = 11900;
-- А если в таблице то найдет это вставленное значение
SELECT * FROM orders WHERE order_id = 11900;

-- Так создавая представление с ограничением WITH LOCAL CHECK OPTION, мы можем запретить вставлять данные несоответсующие фильтру в представлении, будет вызвана ошибка
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100
WITH LOCAL CHECK OPTION;

-- WITH CASCADE CHECK OPTION - тоже, но будет проверяться так же для подлежащих представлений, тоесть представлений на которых основано это представление
CREATE OR REPLACE VIEW heavy_orders AS
SELECT * FROM orders WHERE freight > 100
WITH CASCADE CHECK OPTION;

















--
